<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Занятия по фронтэнду</title>
    <atom:link href="http://amiskov.github.io/learn//feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://amiskov.github.io/learn/</link>
    <description>тезисы, примеры и домашние задания</description>
    <pubDate>Wed, 14 Oct 2015 10:30:00 +0300</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Webpack</title>
      <link>http://amiskov.github.io/learn//learn/articles/webpack/</link>
      <pubDate>Wed, 14 Oct 2015 10:30:00 +0300</pubDate>
      <guid isPermaLink="true">http://amiskov.github.io/learn//learn/articles/webpack/</guid>
      <author></author>
      <description>&lt;p&gt;Вебпак — это сборщик модулей. Любой ресурс для Вебпака является модулейм — js-файл, картинка, шрифт, less, CSS, HTML и пр. Вебпак позволяет организовать зависимости и асинхронную подгрузку.&lt;/p&gt;
&lt;p&gt;По этому материалу есть &lt;a href=&quot;http://amiskov.github.io/learn/articles/webpack/#-homework-&quot;&gt;домашнее задание&lt;/a&gt;.
&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Система модулей&lt;/h1&gt;
&lt;p&gt;Для Вебпака любой ресурс — это модуль. JS, CSS, картинка, шрифт и пр. По умолчанию Вебпак обрабатывает js-модули, для других ресурсов нужно использовать лоадеры:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// файл simple-product.js&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; $ = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'jquery'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// пакет из node_modules&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; Product = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'./product'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// наш файл&lt;/span&gt;

&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SimpleProduct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Product&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Лоадеры&lt;/h2&gt;
&lt;p&gt;Вебпак позволяет работать с картинками, CSS, шрифтами  и пр. ресурсами как с модулями (их так же можно реквайрить и сохранять в переменные).&lt;/p&gt;
&lt;p&gt;Если просто написать &lt;code&gt;require(&amp;#39;./some.css&amp;#39;)&lt;/code&gt;, то при сборке будет ошибка. Вебпак хавает из коробки только js. Для того, чтобы это заработал, например, css-модуль, надо пропустить его подключение через лоадер.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;css-loader&lt;/code&gt; сделает возможной подгрузку CSS-модуля (обернет CSS-файл в js). Содержимое будет можно зареквайрить, сохранить в переменную, но стиль не применится.&lt;/p&gt;
&lt;p&gt;Чтобы стиль применился, нужно использовать &lt;code&gt;style-loader&lt;/code&gt;, который уже встроит стиль в страницу.&lt;/p&gt;
&lt;p&gt;Получаем:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'style!css!./some.css'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// Стили подгрузятся как модуль и применятся на странице&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Любые подключения шрифтов, картинок и пр. в CSS-файлах Вебпак рассматривает как подключение модуля. Поэтому без соответствующих лоадеров будет ошибка.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;file-loader&lt;/code&gt; переносит ресурс в папку со сборкой, &lt;code&gt;url-loader&lt;/code&gt; делает так же, но, если размер ресурса (картинки) достаточно мал, может запаковать его в base-64 и встроить в CSS.&lt;/p&gt;
&lt;p&gt;Не нужно каждый раз писать руками &lt;code&gt;style!css!less&lt;/code&gt;, эту настройку лучше задать в конфиге.&lt;/p&gt;
&lt;p&gt;Соглашение:
&lt;code&gt;test&lt;/code&gt; используется для првоерки расширения.
&lt;code&gt;include&lt;/code&gt; - для проверки путей.
&lt;a href=&quot;http://webpack.github.io/docs/configuration.html#module-loaders&quot;&gt;http://webpack.github.io/docs/configuration.html#module-loaders&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://webpack.github.io/docs/list-of-loaders.html&quot;&gt;Список лоадеров&lt;/a&gt; для Вебпака на официальном сате.&lt;/p&gt;
&lt;h2 id=&quot;preloaders&quot;&gt;PreLoaders&lt;/h2&gt;
&lt;p&gt;Иногда нужно работать с кодом до того, как его модифицировать. Например, проверить JS с помощью линтера. Для этих 
целей предусмотрен механизм прелоадеров. Они запускаются перед лоадерами.&lt;/p&gt;
&lt;p&gt;Пример подключения &lt;a href=&quot;https://github.com/MoOx/eslint-loader&quot;&gt;ESLint&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = {
  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: {
    preLoaders: [
      {test: &lt;span class=&quot;regexp&quot;&gt;/\.js$/&lt;/span&gt;, loader: &lt;span class=&quot;string&quot;&gt;&quot;eslint-loader&quot;&lt;/span&gt;, exclude: &lt;span class=&quot;regexp&quot;&gt;/node_modules/&lt;/span&gt;}
    ]
  }
  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-require-ensure-&quot;&gt;Асинхронная подгрузка модулей (&lt;code&gt;require.ensure&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;Вебпак дополняет синтаксис CommonJS для работы с модулями своим методом &lt;code&gt;.ensure&lt;/code&gt;. Этот метод позволяет организовать асинхронную подгрузку:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([&lt;span class=&quot;string&quot;&gt;'./lib'&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;require&lt;/span&gt;) &lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;// Аргумент — функция реквайра&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; lib = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'./lib'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// загрузится отдельным запросом&lt;/span&gt;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Можно и без явного указания массива модулей и аргумента:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{ 
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; lib = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'./lib'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// Вебпак найдет реквары тут и дальше сам разберется&lt;/span&gt;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Удобно использовать, например, с jQuery-плагинами, которые что-то отрисовывают не сразу. Например, для слайдера с большими картинками можно асинхронно подключить нужный модуль с плагином, стилями и картинками, а потом после загрузки уже его инициализировать.&lt;/p&gt;
&lt;p&gt;Если нужно объединить несколько подключений &lt;code&gt;require.ensure&lt;/code&gt; в один файл (схожий функционал), то третьим параметром можно передать название такого функционала. Все &lt;code&gt;require.ensure&lt;/code&gt; с таким именем объединятся в один файл:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// login.js&lt;/span&gt;
$logoutButton.click = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; login = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'./login'&lt;/span&gt;);
        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
    }, &lt;span class=&quot;string&quot;&gt;'auth'&lt;/span&gt;);
};

&lt;span class=&quot;comment&quot;&gt;// logout.js&lt;/span&gt;
$logoutButton.click = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; login = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'./logout'&lt;/span&gt;);
        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
    }, &lt;span class=&quot;string&quot;&gt;'auth'&lt;/span&gt;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вебпак создаст файл &lt;code&gt;auth.js&lt;/code&gt; и будет его подгружать динамечески, когда понадобиться.&lt;/p&gt;
&lt;h2 id=&quot;bundle-loader&quot;&gt;Bundle loader&lt;/h2&gt;
&lt;p&gt;Позволяет загружать &lt;code&gt;require.esure([выражение])&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;-commonschunkplugin-&quot;&gt;Выделение общего кода (CommonsChunkPlugin)&lt;/h1&gt;
&lt;p&gt;Вебпак позволяет выделить общий код из всех точек входа с помощью &lt;code&gt;CommonsChunkPlugin&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;-jquery-&quot;&gt;Подключение jQuery и других библиотек с глобальными переменными&lt;/h1&gt;
&lt;p&gt;Самый простой способ подключить такую библиотеку — просто отдельный тег &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;. Но с Вебпаком можно сделать более
 интересные вещи.&lt;/p&gt;
&lt;h2 id=&quot;script-loader&quot;&gt;script-loader&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;script-loader&lt;/code&gt; сэмулирует такое поключение библиотеки отдельных тегом &lt;code&gt;&amp;lt;script src=&amp;quot;path/to/jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;, но при этом библиотека будет включена в сборочный файл, а мы сэкономим один запрос:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// index.js&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'script!jquery'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// Взять jquery из node_modules и пропустить через script-loader&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Далее &lt;code&gt;jQuery&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; будут доступны в глобальной области видимости во всех модулях.&lt;/p&gt;
&lt;h2 id=&quot;provideplugin&quot;&gt;ProvidePlugin&lt;/h2&gt;
&lt;p&gt;Как вариант, можно использовать &lt;code&gt;ProvidePlugin&lt;/code&gt;, который автоматически будет подключать модуль, если найдет переменную. Например, вот эта настройка говорит, что нужно сделать &lt;code&gt;require(&amp;#39;jquery&amp;#39;)&lt;/code&gt;, если найдется в файле &lt;code&gt;$&lt;/code&gt;,
&lt;code&gt;jQuery&lt;/code&gt; или &lt;code&gt;window.jQuery&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;plugins: [ 
  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; webpack.ProvidePlugin({ 
      $: ‘jquery’, 
      jQuery: ‘jquery’, 
      ‘&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.jQuery’: ‘jquery’
    })
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;externals&quot;&gt;Externals&lt;/h2&gt;
&lt;p&gt;Если библиотека jQuery уже подключена отдельно (например, через CDN), а мы хотим делать &lt;code&gt;require(&amp;#39;jquery&amp;#39;)&lt;/code&gt;, то можно об этом сказать Вбпаку с помощью &lt;code&gt;externals&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;externals: {
    jquery: &lt;span class=&quot;string&quot;&gt;'jQuery'&lt;/span&gt;,
    $: &lt;span class=&quot;string&quot;&gt;'jQuery'&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и дальше уже можно делать &lt;code&gt;require(&amp;#39;jquery&amp;#39;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Подробнее: &lt;a href=&quot;https://webpack.github.io/docs/library-and-externals.html&quot;&gt;https://webpack.github.io/docs/library-and-externals.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;config-files&quot;&gt;Config Files&lt;/h1&gt;
&lt;p&gt;Конфигурационный файл Вебпака — это CommonJS-модуль, который возвращает объект.&lt;/p&gt;
&lt;p&gt;Пример:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = {
    entry: [&lt;span class=&quot;string&quot;&gt;&quot;./utils.js&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;./app.js&quot;&lt;/span&gt;], &lt;span class=&quot;comment&quot;&gt;// сольются в бандле&lt;/span&gt;
    output: {
        filename: &lt;span class=&quot;string&quot;&gt;&quot;bundle.js&quot;&lt;/span&gt;
    },
    {   &lt;span class=&quot;comment&quot;&gt;// Обработка картинок&lt;/span&gt;
        test: &lt;span class=&quot;regexp&quot;&gt;/\.(jp?g|gif|png)$/&lt;/span&gt;,
        exclude: &lt;span class=&quot;regexp&quot;&gt;/node_modules/&lt;/span&gt;,
        loader: &lt;span class=&quot;string&quot;&gt;'url-loader?limit=1024&amp;amp;name=[path][name].[hash].[ext]'&lt;/span&gt;
        &lt;span class=&quot;comment&quot;&gt;// [hash] — автоматически генерируемый код. &lt;/span&gt;
        &lt;span class=&quot;comment&quot;&gt;// Нужен для лучшего кеширования.&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь в терминале можно просто сказать &lt;code&gt;webpack&lt;/code&gt; и все настройки возьмутся из конфига.&lt;/p&gt;
&lt;p&gt;Конфиг можно реквайрить в другие конфиги. Например, в конфиг для проакшена можно зареквайрить конфиг для дева.&lt;/p&gt;
&lt;h1 id=&quot;command-line-interface-cli-&quot;&gt;Command Line Interface (CLI)&lt;/h1&gt;
&lt;p&gt;Установка Вебпака на уровне системы (чтобы запускать из любого места на диске):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install webpack -g
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Пример использования: &lt;code&gt;webpack ./app.js bundle.js&lt;/code&gt;. Вебпак подключит все зависимости из &lt;code&gt;app.js&lt;/code&gt;, сделает с ними так, как прописано в конфиге и сохранит результат в &lt;code&gt;bundle.js&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;watch-mode&quot;&gt;Watch mode&lt;/h1&gt;
&lt;p&gt;Включить режим пересборки при изменении файлов можно в командной строке: &lt;code&gt;webpack --watch&lt;/code&gt; или в файле конфига инструкцией &lt;code&gt;watch: true&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;webpack-dev-server&quot;&gt;Webpack Dev Server&lt;/h1&gt;
&lt;p&gt;В Вебпак встроен веб-сервер для удобства разработки. Туда же включен и ливрелоад.&lt;/p&gt;
&lt;p&gt;Сервер нужно установить отдельно: &lt;code&gt;npm install webpack-dev-server -g&lt;/code&gt;. После установки мы можем его запускать: &lt;code&gt;webpack-dev-server&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Вебпак-сервер предложит смотреть страницу по адресу &lt;code&gt;http://localhost:8080/webpack-dev-server/&lt;/code&gt;. Там будет панелька 
сверху, а разрабатываемый сайт будет исполняться во фрейме.&lt;/p&gt;
&lt;p&gt;Если запустить просто &lt;code&gt;http://localhost:8080/&lt;/code&gt;, лишней панельки не будет, но сервер будет работать без ливрелоада.
Это можно исправить, запустив веб-сервер с флагом &lt;code&gt;inline&lt;/code&gt;: &lt;code&gt;webpack-dev-server --inline&lt;/code&gt;. &lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Скрипты запуска&lt;/h1&gt;
&lt;p&gt;Для сокращенного синтаксиса запуска Вебпака с параметрами можно использовать NPM. В &lt;code&gt;package.json&lt;/code&gt; есть свойство &lt;code&gt;&amp;quot;scripts&amp;quot;: {}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Исполнить их можно командой &lt;code&gt;npm run scriptname&lt;/code&gt;. Пример:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;scripts&quot;&lt;/span&gt;: {
    &lt;span class=&quot;string&quot;&gt;&quot;server&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;webpack-dev-server --hot --inline --devtool eval --progress --colors&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;dev&quot;&lt;/span&gt;:    &lt;span class=&quot;string&quot;&gt;&quot;env DEV=true server&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;prod&quot;&lt;/span&gt;:   &lt;span class=&quot;string&quot;&gt;&quot;webpack -p --config webpack.config.production.js&quot;&lt;/span&gt;
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Запустить скрипты из командной строки можно с помощью &lt;code&gt;npm run&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Сборка для продакшена: &lt;code&gt;npm run prod&lt;/code&gt;. Вебпак возьмет настройки из файла &lt;code&gt;webpack.production.js&lt;/code&gt;.
Флаг &lt;code&gt;-p&lt;/code&gt; (он же &lt;code&gt;--optimize-minimize&lt;/code&gt;) включает минификацию и обфускацию кода (работает из коробки).&lt;/p&gt;
&lt;p&gt;Запустить дев-сервер: &lt;code&gt;npm run server&lt;/code&gt;. Установится переменная окружения &lt;code&gt;DEV=true&lt;/code&gt; и запустится сервер с полезными 
при работе параметрами.&lt;/p&gt;
&lt;p&gt;Подробнее: &lt;a href=&quot;http://jaketrent.com/post/list-npm-scripts/&quot;&gt;http://jaketrent.com/post/list-npm-scripts/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Минификация&lt;/h1&gt;
&lt;p&gt;Можно настроить Uglify вручную и только на продакшене через &lt;code&gt;NODE_ENV&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Переменные окружения&lt;/h1&gt;
&lt;p&gt;Так работает на Винде и на Юниксе: &lt;code&gt;npm run env NODE_ENV=production&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Так только на Юниксе: &lt;code&gt;npm run NODE_ENV=production&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Так только на Винде: &lt;code&gt;npm run set NODE_ENV=production&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Так переменная сохранится в настройках терминала: &lt;code&gt;export NODE_ENV=production&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Подробнее: &lt;a href=&quot;https://docs.npmjs.com/cli/run-script&quot;&gt;https://docs.npmjs.com/cli/run-script&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Плагины&lt;/h1&gt;
&lt;p&gt;Модифицировать процесс сборки можно с помощью плагинов. Есть плагины, которые генерируют html-файлы, объявляют глобальные переменные, выносят код в отдельные файлы, оптимизируют модули и пр. См. &lt;a href=&quot;https://webpack.github.io/docs/list-of-plugins.html&quot;&gt;список плагинов&lt;/a&gt; на сайте Вебпака.&lt;/p&gt;
&lt;p&gt;Например, у нас есть модуль &lt;code&gt;simpleProduct.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'./simple_product.less'&lt;/span&gt;);

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Product = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'./product.js'&lt;/span&gt;);
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; simpleProduct = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Product();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Здесь первой строкой подулючаются стили. Вебпак приготовит свой js-бандл при сборке и добавит их прямо в js-файл. &lt;/p&gt;
&lt;p&gt;Если нам нужно эти стили вынести в файл и подключить отедльно, можно использовать &lt;code&gt;ExtractTextPlugin&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// webpack.config.js&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ExtractTextPlugin = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;extract-text-webpack-plugin&quot;&lt;/span&gt;),
&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = {
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: {
        loaders: [
            {
                test: &lt;span class=&quot;regexp&quot;&gt;/simple_product.less$/&lt;/span&gt;,
                exclude: &lt;span class=&quot;regexp&quot;&gt;/node_modules/&lt;/span&gt;,
                loader: ExtractTextPlugin.extract(&lt;span class=&quot;string&quot;&gt;'style-loader'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'css-loader!autoprefixer-loader!less-loader'&lt;/span&gt;)
            }
            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
        ]
    },
    plugins: [
        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExtractTextPlugin(&lt;span class=&quot;string&quot;&gt;'[name].css'&lt;/span&gt;)
    ]
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;С помощью плагинов можно сильно изменить процесс сборки. Вебпак позволит сделать многое.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://webpack.github.io/docs/stylesheets.html#separate-css-bundle&quot;&gt;Подробнее&lt;/a&gt; про вынос стилей в отдельынй файл.&lt;/p&gt;
&lt;p&gt;О плагинах: &lt;a href=&quot;http://webpack.github.io/docs/plugins.html&quot;&gt;http://webpack.github.io/docs/plugins.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;source-maps&quot;&gt;Source maps&lt;/h1&gt;
&lt;p&gt;Сорсмапы встроены в Вебпак. Включить их можно параметром: &lt;code&gt;webpack -d&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;-multiple-bundles-&quot;&gt;Несколько точек входа (multiple bundles)&lt;/h1&gt;
&lt;p&gt;Для сайтов, которые состоят более чем из одной страницы, хорошим тоном будет раскидать функциональность по отдельным файлам. Например, на Хомпейдже нам не нужен скрипт для валидации формы изменения пароля для залогиненого пользователя:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = {
    entry: {
        home: &lt;span class=&quot;string&quot;&gt;'./src/home.js'&lt;/span&gt;,
        account: &lt;span class=&quot;string&quot;&gt;'./src/account.js'&lt;/span&gt;,
        checkout: &lt;span class=&quot;string&quot;&gt;'./src/checkout.js'&lt;/span&gt;
        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
    },
    output: {
        filename: [name].js &lt;span class=&quot;comment&quot;&gt;// назвать файлы как и точки входа&lt;/span&gt;
        path: __dirname + &lt;span class=&quot;string&quot;&gt;'/dist'&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// и положить в директорию /dist&lt;/span&gt;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Зависимость от точки входа запрещена. Реквайрить &lt;code&gt;about.js&lt;/code&gt; из &lt;code&gt;home.js&lt;/code&gt; не выйдет. Надо, чтобы &lt;code&gt;about.js&lt;/code&gt; в этом случае был не точкой входа, а модулем.&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Статистика&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;webpack --json --profile &amp;gt; stats.json&lt;/code&gt; — вывести статистику в json-файл с учетом временных параметров.&lt;/p&gt;
&lt;p&gt;Проверить: &lt;a href=&quot;http://webpack.github.io/analyse/&quot;&gt;http://webpack.github.io/analyse/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Материалы&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.javascript.ru/webpack-screencast&quot;&gt;Скринкаст Webpack&lt;/a&gt; от Ильи Кантора. Обязательно к просмотру.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=TaWKUpahFZM&quot;&gt;Getting Started with webpack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dontkry.com/posts/code/single-page-modules-with-webpack.html&quot;&gt;http://dontkry.com/posts/code/single-page-modules-with-webpack.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[Webpack Howto)(&lt;a href=&quot;https://github.com/petehunt/webpack-howto&quot;&gt;https://github.com/petehunt/webpack-howto&lt;/a&gt;) от Пита Ханта из Инстаграмма + &lt;a href=&quot;http://youtu.be/VkTCL6Nqm6Y&quot;&gt;доклад&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@dtothefp/why-can-t-anyone-write-a-simple-webpack-tutorial-d0b075db35ed&quot;&gt;Why can’t anyone write a simple webpack tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;-homework-&quot;&gt;Домашняя работа &lt;a href=&quot;http://amiskov.github.io/learn/articles/webpack/#homework&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;На странице есть слайдер с довольно большими картинками. Слайдер реализован с помощью jQuery-плагина (&lt;a href=&quot;http://kenwheeler.github.io/slick/&quot;&gt;Slick&lt;/a&gt;). Нам нужно, чтобы все, что касается слайдера (стили, картинки, скрипты) грузилось асинхронно и не влияло на загрузку основного контента.&lt;/p&gt;
&lt;p&gt;Пример реализации: &lt;a href=&quot;http://amiskov.github.io/examples/webpack-slider/&quot;&gt;http://amiskov.github.io/examples/webpack-slider/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Скелет проекта есть на &lt;a href=&quot;https://github.com/amiskov/webpack-slider&quot;&gt;Гитхабе&lt;/a&gt;. Вы просто запускаете &lt;code&gt;npm install&lt;/code&gt;, скачиваются необходимые модули, в том числе jQuery и Slick. Остается только закодить слайдер.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>jQuery Deferred/Promise</title>
      <link>http://amiskov.github.io/learn//learn/articles/jquery-deferred/</link>
      <pubDate>Wed, 07 Oct 2015 10:30:00 +0300</pubDate>
      <guid isPermaLink="true">http://amiskov.github.io/learn//learn/articles/jquery-deferred/</guid>
      <author></author>
      <description>&lt;p&gt;При работе с асинхронными процессами код становится сложнее. Функции обратного вызова (коллбэки) не всегда достаточно
удобны. При использовании колбэков код может быть перегражен вложенными конструкциями и потерей производительности.
Для решения этих проблем придумали механизм отложенного исполнения. В jQuery он реализован с помощь deferred-объектов.
&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;deferred&quot;&gt;Deferred&lt;/h1&gt;
&lt;p&gt;К объекту с отложенным вызовом обработчиков (deferred-объект) мы можем прикрепить код, который сработает при успешном
или неуспешном выполении действия в будущем.&lt;/p&gt;
&lt;p&gt;Deferred — объект для хранения состояния. К каждому состоянию объекта можно прикрепить функционал, выполняемый 
когда-то в 
будущем:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; d = $.Deferred(); &lt;span class=&quot;comment&quot;&gt;// Объект, отвечающий за выполнение чего-то в будущем&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;/*
    Запускаем процесс, занимающий неопределенное время: аяксовый запрос, таймер, анимация и пр.
    После успешного завершения процесса вызываем d.resolve(DATA).
    Если возникла ошибка, вызываем d.reject(DATA).
    Во время выполнения процесса d находится в стадии `progress'. Это можно увидеть с помощью d.state().
*/&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Сделать это, когда все будет хорошо&lt;/span&gt;
d.done(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;{
    alert(value)
});

&lt;span class=&quot;comment&quot;&gt;// Сделать это, когда будет ошибка&lt;/span&gt;
d.fail(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;{
    alert(value);
});

&lt;span class=&quot;comment&quot;&gt;// Сделать это в любом случае&lt;/span&gt;
d.always(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;{
    alert(value);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот код работает, но наш объект &lt;code&gt;d&lt;/code&gt; открыт внешнему миру. Любой код, которому доступен &lt;code&gt;d&lt;/code&gt; может изменить его 
состояние. Это потенциальная проблема. Ее можно решить, ограничив доступ к методам &lt;code&gt;resolve&lt;/code&gt; и &lt;code&gt;reject&lt;/code&gt; нашего 
deferred-объекта.&lt;/p&gt;
&lt;h1 id=&quot;promise&quot;&gt;Promise&lt;/h1&gt;
&lt;p&gt;Зачастую нам не нужно давать возможность изменять состояние deferred-объекта. Мы чаще хотим просто дать возможность 
прикреплять обработчики. Для этого реализован метод &lt;code&gt;d.promise()&lt;/code&gt;. Он вернет deferred-объект без возможности 
зарезолвить или зареджектить его. Можно будет только прикрепить к нему обработчики, а менять его будет нельзя.&lt;/p&gt;
&lt;p&gt;Метод &lt;code&gt;$.ajax&lt;/code&gt; возвращает промис. И мы можем наряду с &lt;code&gt;success&lt;/code&gt; и &lt;code&gt;error&lt;/code&gt; использовать &lt;code&gt;.done&lt;/code&gt; и &lt;code&gt;.fail&lt;/code&gt;. Это 
даст возможность избавиться от вложенных методов и прикрепить несколько обработчиков. Код станет читабельнее и гибче.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; promise = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; d = $.Deferred(); &lt;span class=&quot;comment&quot;&gt;// Объект, отвечающий за выполнение чего-то в будущем&lt;/span&gt;

    asyncProcess(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;comment&quot;&gt;// Прощесс пошел...&lt;/span&gt;
        &lt;span class=&quot;comment&quot;&gt;// Если все пройдет успешно, запустим d.resolve();&lt;/span&gt;
        &lt;span class=&quot;comment&quot;&gt;// Если будет ошибка, запустим d.reject();&lt;/span&gt;
    });

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; d.promise(); &lt;span class=&quot;comment&quot;&gt;// Вернуть не объект d, а ограниченный интерфейс к нему — promise&lt;/span&gt;
})();


&lt;span class=&quot;comment&quot;&gt;// Сделать это, когда все будет хорошо&lt;/span&gt;
promise.done(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;{
    alert(value)
});

&lt;span class=&quot;comment&quot;&gt;// Сделать это, когда будет ошибка&lt;/span&gt;
promise.fail(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;{
    alert(value);
});

&lt;span class=&quot;comment&quot;&gt;// Сделать это в любом случае&lt;/span&gt;
promise.always(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;{
    alert(value);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Promise is a read-only jQuery Deferred object.&lt;/p&gt;
&lt;h1 id=&quot;-deferred-promise&quot;&gt;Терминология: Deferred и Promise&lt;/h1&gt;
&lt;p&gt;Все делает Deferred.&lt;/p&gt;
&lt;p&gt;Promise — это неразрушающий интерфейс к объекту Deferred. Лучше не давать внешнему коду лезть в deferred, чтобы ничто 
левое не запустило &lt;code&gt;resolve&lt;/code&gt; или &lt;code&gt;reject&lt;/code&gt;. Промис как секретарь фильтрует только неизменяющие 
запросы к deferred. См. &lt;a href=&quot;/learn/articles/jquery-deferred/deferred_vs_promise.html&quot;&gt;deferred_vs_promise.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Мы пришли в ресторан, свободных столов нет. Система ресторана может прислать смс, когда освободится стол, который нам
понравился.&lt;/p&gt;
&lt;p&gt;Мы можем заказать стол на будущее. Оставить номер телефона и система сама пришлет нам смс, когда стол освободится.
Официант создаст для нас Deferred, зарегистрировав наш заказ. Но он не пустит нас к компьютеру, чтобы мы не нажали 
кнопку “Стол свободен” раньше времени. Он только добавит наш телефон в систему — это наш единственный интерфейс.&lt;/p&gt;
&lt;p&gt;Смс соответствуюет Promise.
Пока стол будет занят, мы можем прогуляться, выпить чего-нибудь в баре, а не тупо стоять в очереди. А когда стол 
освободится, то promise станет resolved и нам придет смс. Мы никак не можем повлиять на сообщение.&lt;/p&gt;
&lt;p&gt;Физическая очередь ожидания — это синхронное решение. Оставь телефон и делай что хочешь — это асинхронное решение.&lt;/p&gt;
&lt;h1 id=&quot;-jquery-&quot;&gt;Какие функции jQuery возвращают промис?&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;$.ajax&lt;/code&gt; возвращает промис.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.animate.promise()&lt;/code&gt; возвращает промис.&lt;/p&gt;
&lt;p&gt;У коллекции элементов есть метод &lt;code&gt;$(&amp;#39;div&amp;#39;).promise()&lt;/code&gt;, который возвращает промис. Используется для отслеживания 
окончания анимации над всей коллекцией. См. &lt;a href=&quot;/learn/articles/jquery-deferred/dom_promise.html&quot;&gt;dom_promise.html&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;-deferred-&quot;&gt;Методы deferred-объектов и их промисов&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;done&lt;/em&gt; — говорит, что делать, когда deferred будет resolved. Может быть вызван &lt;em&gt;несколько раз&lt;/em&gt; над одним и тем же 
объектом, чтобы делать разные штуки, когда deferred будет отрезолвлен. Все вызовы &lt;code&gt;done&lt;/code&gt; — независимы. Мы не можем 
передавать аргумент от одного вызова этого метода к другому. Все колбэки в &lt;code&gt;done&lt;/code&gt; будут вызваны с одним и тем же 
аргументом. Для того, чтобы модифицировать контекст нужно использовать &lt;code&gt;then&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;promise.done(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;)&lt;/span&gt;{
    &lt;span class=&quot;comment&quot;&gt;// result is the value with which the deferred was resolved.&lt;/span&gt;
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;'The promise was resolved with'&lt;/span&gt;, result);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;fail&lt;/em&gt; — метод, который вызывается, когда deferred is rejected. Работает как &lt;code&gt;done&lt;/code&gt;, только для обработки ошибок:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;promise.fail(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;)&lt;/span&gt;{
    &lt;span class=&quot;comment&quot;&gt;// error is the value with which the deferred was rejected.&lt;/span&gt;
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;'The promise was rejected with'&lt;/span&gt;, error);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;always&lt;/em&gt; - если не важно, resolved или rejected. Полезно для логирования или чтоб прибраться. В колбэк приходит 
параметр, по которому мы не сможем понять, октлонен ли промис или зарезолвлен. Если это важно, то вместо always лучше
использовать другие мтеоды.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;state&lt;/em&gt; может быть ‘resolved’, ‘rejected’, ‘pending’. Может быть нужно для отладки. Работает у промисов и деферредов.&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Аякс в аяксе&lt;/h1&gt;
&lt;p&gt;Почему плохо?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.ajax({
    success: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        $.ajax({
            success: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
                $.ajax({
                    success: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
                        &lt;span class=&quot;comment&quot;&gt;// render all data&lt;/span&gt;
                    }
                });
            }
        })
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Так мы не используем асинхронность. Посылает 3 последовательных запроса один после отработки другого. Долго.
Плохо читается код. Сильная вложенность.&lt;/p&gt;
&lt;h1 id=&quot;then&quot;&gt;then&lt;/h1&gt;
&lt;p&gt;Позволяет передавать контекст последовательно между обработчиками. &lt;code&gt;then&lt;/code&gt; создает новый Deferred-объект и возвращает
новый промис.&lt;/p&gt;
&lt;p&gt;Пример последовательной передачи контекста при помощи &lt;code&gt;then&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;login(&lt;span class=&quot;string&quot;&gt;'user:password@server'&lt;/span&gt;)
    .then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;server&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; server.open(&lt;span class=&quot;string&quot;&gt;'db'&lt;/span&gt;);
    })
    .then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;db&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; db.query(query);
    })
    .then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;view&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fetchRows(view);
    }, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleError&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) &lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;// Сюда свалятся все ошибки цепочки.&lt;/span&gt;
        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(err);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;См. так же &lt;a href=&quot;/learn/articles/jquery-deferred/then_example.html&quot;&gt;then_example.html&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;when&quot;&gt;when&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;$.when&lt;/code&gt; - это отдельная функция. Она над промисами и дефердами. Применяется, когда нужно исполнить действие только 
после того, как несколько дефердов отрезолвятся.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$.when&lt;/code&gt; возвращает один deferred, который основан на нескольких. Отрезолвились те, отрезолвился и этот.&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Домашняя работа&lt;/h1&gt;
&lt;p&gt;Все необходимые файлы есть на &lt;a href=&quot;http://plnkr.co/edit/Ffm3w9nhRMpYVibRopgi&quot;&gt;Планкере&lt;/a&gt;, нужно только написать нужный JS.&lt;/p&gt;
&lt;p&gt;Задача: Организовать подгрузку страниц аяксом с помощью промисов как показано на картинке:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/learn/articles/jquery-deferred/hw_deferred.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Home и About подгружают HTML-файлы, Contacts подгружает HTML-файл и еще JSON со ссылками на социальные сети. Путь к 
json-файлу прописан в соответствующем data-атрибуте. &lt;/p&gt;
&lt;p&gt;Контент нужно кешировать после первого запроса, чтобы не грузить его по нескольку раз, если пользователь решит 
походить по ссылкам туда-сюда. На картинке, в панели Network можно заметить, что при повторном клике на ссылку запрос
не отсылается.&lt;/p&gt;
&lt;p&gt;Код должен быть архитектурно продуман и удобно организован. Напримар, страница — это объект, который создается с 
помощью конструктора.&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Материалы&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vimeo.com/74925301&quot;&gt;Promise – это не больно | FrontTalks 2013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://youtu.be/juRtEEsHI9E&quot;&gt;I .promise() to show you .when() to use Deferreds&lt;/a&gt; + &lt;a href=&quot;https://github.com/alexmcpherson/jquery-talk&quot;&gt;код и слайды&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.jquery.com/code-organization/deferreds/&quot;&gt;Deferreds, learn.jquery.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;Deferred object, api.jquery.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/company/bankrot-pro/blog/230441/&quot;&gt;JQuery Deferred — примеры использования&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://valera-rozuvan.github.io/nintoku/jquery/promises/jquery-broken-promises-illustrated/&quot;&gt;jQuery broken promises illustrated&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>jQuery Code Organization</title>
      <link>http://amiskov.github.io/learn//learn/articles/jquery-code-organization/</link>
      <pubDate>Wed, 23 Sep 2015 10:30:00 +0300</pubDate>
      <guid isPermaLink="true">http://amiskov.github.io/learn//learn/articles/jquery-code-organization/</guid>
      <author></author>
      <description>&lt;p&gt;Кратко о самых простых способах организации кода.
&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Основные моменты&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Код нужно дробить на модули — небольшие функциональные блоки.&lt;/li&gt;
&lt;li&gt;Не нужно копипастить код. Для этого есть наследование.&lt;/li&gt;
&lt;li&gt;jQuery плотно работает с DOM, однако яваскрипт-модули (приложение) — это не про DOM. Функционал не нужно 
привязывать к DOM.&lt;/li&gt;
&lt;li&gt;Модули должны существовать максимально обособлено (слабое зацепление). Коммуникацию между модулями нужно 
организовывать с помощью событий или pub/sub (!!!).&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;-&quot;&gt;Инкапсуляция&lt;/h1&gt;
&lt;p&gt;Приложение нужно разделять на функциональные блоки — модули. Зачастую этого уже достаточно для грамотной организации 
кода.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Объявление объекта&lt;/h2&gt;
&lt;p&gt;Самый простой способ для изоляции кода — использовать объект. Мы не получим приватных методов и свойств, но объект 
позволит нам избежать анонимных функций, выделить конфигурацию (опции), упростить поддержку кода и рефакторинг:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// An object literal&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myFeature = {
    myProperty: &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;,

    myMethod: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( myFeature.myProperty );
    },

    init: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; settings &lt;/span&gt;) &lt;/span&gt;{
        myFeature.settings = settings;
    },

    readSettings: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( myFeature.settings );
    }
};

myFeature.myProperty === &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;

myFeature.myMethod(); &lt;span class=&quot;comment&quot;&gt;// &quot;hello&quot;&lt;/span&gt;

myFeature.init({
    foo: &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;
});

myFeature.readSettings(); &lt;span class=&quot;comment&quot;&gt;// { foo: &quot;bar&quot; }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Прием проектирования «Модуль»&lt;/h2&gt;
&lt;p&gt;Позволяет делать приватные методы и открывать доступ только к необходимому функционалу.&lt;/p&gt;
&lt;p&gt;Мы уже рассматривали ранее этот прием, почитать можно &lt;a href=&quot;http://learn.javascript.ru/closures-module&quot;&gt;тут&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Анонимные функции&lt;/h2&gt;
&lt;p&gt;Анонимные функции тяжело читаемы, их неудобно поддерживать, тестироватиь, повторно использовать код.&lt;/p&gt;
&lt;p&gt;Вместо анонимных функций нужно использовать именованные или организовывать код в виде объектов:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// BAD&lt;/span&gt;
$( &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt; ).ready(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    $( &lt;span class=&quot;string&quot;&gt;&quot;#magic&quot;&lt;/span&gt; ).click(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; event &lt;/span&gt;) &lt;/span&gt;{
        $( &lt;span class=&quot;string&quot;&gt;&quot;#yayeffects&quot;&lt;/span&gt; ).slideUp(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
        });
    });

    $( &lt;span class=&quot;string&quot;&gt;&quot;#happiness&quot;&lt;/span&gt; ).load( url + &lt;span class=&quot;string&quot;&gt;&quot; #unicorns&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
    });

});

&lt;span class=&quot;comment&quot;&gt;// BETTER&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; PI = {

    onReady: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        $( &lt;span class=&quot;string&quot;&gt;&quot;#magic&quot;&lt;/span&gt; ).click( PI.candyMtn );
        $( &lt;span class=&quot;string&quot;&gt;&quot;#happiness&quot;&lt;/span&gt; ).load( PI.url + &lt;span class=&quot;string&quot;&gt;&quot; #unicorns&quot;&lt;/span&gt;, PI.unicornCb );
    },

    candyMtn: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; event &lt;/span&gt;) &lt;/span&gt;{
        $( &lt;span class=&quot;string&quot;&gt;&quot;#yayeffects&quot;&lt;/span&gt; ).slideUp( PI.slideCb );
    },

    slideCb: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{ ... },

    unicornCb: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{ ... }

};

$( &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt; ).ready( PI.onReady );
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-dry-don-t-repeat-yourself-&quot;&gt;Не нужно копипастить (DRY — Don’t Repeat Yourself)&lt;/h2&gt;
&lt;p&gt;Повторение кода очень вредно. Попробуйте что-то изментиь, придется лазить по всему коду:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// BAD&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( eventfade.data( &lt;span class=&quot;string&quot;&gt;&quot;currently&quot;&lt;/span&gt; ) !== &lt;span class=&quot;string&quot;&gt;&quot;showing&quot;&lt;/span&gt; ) {
    eventfade.stop();
}

&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( eventhover.data( &lt;span class=&quot;string&quot;&gt;&quot;currently&quot;&lt;/span&gt; ) !== &lt;span class=&quot;string&quot;&gt;&quot;showing&quot;&lt;/span&gt; ) {
    eventhover.stop();
}

&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( spans.data( &lt;span class=&quot;string&quot;&gt;&quot;currently&quot;&lt;/span&gt; ) !== &lt;span class=&quot;string&quot;&gt;&quot;showing&quot;&lt;/span&gt; ) {
    spans.stop();
}

&lt;span class=&quot;comment&quot;&gt;// GOOD!!&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; elems = [ eventfade, eventhover, spans ];

$.each( elems, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; i, elem &lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( elem.data( &lt;span class=&quot;string&quot;&gt;&quot;currently&quot;&lt;/span&gt; ) !== &lt;span class=&quot;string&quot;&gt;&quot;showing&quot;&lt;/span&gt; ) {
        elem.stop();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;Смотреть браузер или фичу?&lt;/h1&gt;
&lt;p&gt;Если нужно использовать какой-то функционал, котоырй не всеми поддерживается, то можно определить браузер или 
определить, пожддерживается ли фича. Второй способ предпочтительнее.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Минусы определения браузера&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Другие браузеры могут тоже содержать/не содержать нужную нам фичу.&lt;/li&gt;
&lt;li&gt;Со временем фича может добавляться/меняться&lt;/li&gt;
&lt;li&gt;Браузер может подменить строку UA&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;-&quot;&gt;Определение фичи без библиотеки&lt;/h2&gt;
&lt;p&gt;Чтобы определить, работает ли что-то в браузере, мы пробуем, и смотрим, что получилось. Это просто, но долго:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// We want to show a graph in browsers that support canvas,&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// but a data table in browsers that don't.&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; elem = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.createElement( &lt;span class=&quot;string&quot;&gt;&quot;canvas&quot;&lt;/span&gt; );

&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( elem.getContext &amp;amp;&amp;amp; elem.getContext( &lt;span class=&quot;string&quot;&gt;&quot;2d&quot;&lt;/span&gt; ) ) {
    showGraph();
} &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    showTable();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Предпочтительнее использовать библиотеку Modernizr или аналогичные:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( Modernizr.canvas ) {
    showGraphWithCanvas();
} &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    showTable();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ссылки: &lt;a href=&quot;https://learn.jquery.com/code-organization/feature-browser-detection/#other-resources&quot;&gt;https://learn.jquery.com/code-organization/feature-browser-detection/#other-resources&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>jQuery Widget Factory</title>
      <link>http://amiskov.github.io/learn//learn/articles/jquery-widget-factory/</link>
      <pubDate>Wed, 16 Sep 2015 10:30:00 +0300</pubDate>
      <guid isPermaLink="true">http://amiskov.github.io/learn//learn/articles/jquery-widget-factory/</guid>
      <author></author>
      <description>&lt;p&gt;Если нам нужен компонент, который будет менять состояния, взаимодействовать с другими компонентами, 
включаться/отключаться и т. д., то плагины могут быть не слишком удобны в использовании. Для таких случаев придумали
jQuery Widget Factory.
&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Плагины нужны, чтобы расширить существующий функционал фреймворка. Обычно они запускаются на коллекции, что-то с ней 
делают и возвращают эту же коллекцию, обеспечивая цепочность вызовов.&lt;/p&gt;
&lt;p&gt;Обычно jQuery-плагины применяются без настроек и результат их выполнения всегда одинаков.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$(&amp;#39;div&amp;#39;).text(&amp;#39;Hello&amp;#39;)&lt;/code&gt; — для такого рода операций плагин — самое то. &lt;code&gt;.text()&lt;/code&gt; добавляет текст в элемент и на этом 
его работа заканчивается.&lt;/p&gt;
&lt;p&gt;Если нам нужно произвести инициализацию компонента, следить за его &lt;a href=&quot;http://en.wikipedia.org/wiki/State_%28computer_science%29&quot;&gt;состоянием&lt;/a&gt; и изменять 
его в зависимости от разлиынх условий, то тут потребуется писать код, типичный для многих таких 
виджетов. Разные авторы могут по-разному подходить к реализации своих API. Это влечет снижение консистентности кода и
 лишние затраты времени.&lt;/p&gt;
&lt;p&gt;Для того, чтобы создавать более ООП-ориентированные сущности и в то же время быть в среде jQuery придумали &lt;a href=&quot;http://jqueryui.com/widget/&quot;&gt;jQuery 
Widget Factofy&lt;/a&gt;, которая является частью jQuery UI и может быть использована отдельно 
(7Кб в сжатом виде). &lt;/p&gt;
&lt;h2 id=&quot;widget-factory&quot;&gt;Widget factory&lt;/h2&gt;
&lt;p&gt;Widget factory предоставляет ряд соглашений и готового функционала для того, чтобы написание виджетов было однотипным и 
получаемый API работал одним образом. Сохраняем время на рутинных операциях (инициализация, дестрой, триггеринг 
событий) используем соглашения для приватных и публичных метоодов, получаем более более качественный результат и 
экономим время. Научились использовать один виджет из jQuery UI — умеем пользоваться всеми.&lt;/p&gt;
&lt;p&gt;В Magento 2.0 Widget Factory &lt;a href=&quot;http://devdocs.magento.com/guides/v2.0/coding-standards/code-standard-jquery-widgets.html&quot;&gt;является стандартом&lt;/a&gt; для создания компонентов интерфейса.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Консистентность кода&lt;/h2&gt;
&lt;p&gt;jQuery Widget Factory прежде всего решает задачу по организации кода. Следование соглашениям в команде позволяет не 
тратить время, раздумывая над API виджета при разработке и над вызовом методов, установкой свойств при использовании.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Преимущества&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Наследование и полиморфизм&lt;/li&gt;
&lt;li&gt;Конструктор/Деструктор &lt;code&gt;_create&lt;/code&gt;/&lt;code&gt;_destroy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Псевдоселектор &lt;code&gt;$(&amp;#39;:ns-plugin&amp;#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Приватные и публичные методы&lt;/li&gt;
&lt;li&gt;Механизм колбэков (&lt;code&gt;_trigger&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;-&quot;&gt;Соглашения&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Создание и удаление виджетов;&lt;/li&gt;
&lt;li&gt;Установка и получение опций (геттеры и сеттеры);&lt;/li&gt;
&lt;li&gt;Вызов методов;&lt;/li&gt;
&lt;li&gt;Прослушивание и вызов событий, которые инициирует виджет.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Состояние объекта — набор данных о нем в текущий момент времени: значение (проценты в прогрессбаре), открыт он или 
закрыт, какой пункт выделеин и т. д.&lt;/p&gt;
&lt;p&gt;Виджеты имеют жизненный цикл — от инициализации до дестроя.&lt;/p&gt;
&lt;p&gt;Инициализация прогрессбара:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Без параметров, с дефолтными настройками&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar();
&lt;span class=&quot;comment&quot;&gt;// Со своими параметрами&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar({ value: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Параметры — часть состояния виджета. Их мы можем менять в течение жизненного цикла через метод &lt;a href=&quot;http://api.jqueryui.com/jQuery.widget/#method-option&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Параметры при инициализации&lt;/h2&gt;
&lt;p&gt;Для плагина хорошая практика — набор дефолтных опций и предоставление внешнего интерфейса к ним:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.fn.plugin = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; options &lt;/span&gt;) &lt;/span&gt;{
    options = $.extend( {}, $.fn.plugin.defaults, options );
    &lt;span class=&quot;comment&quot;&gt;// Plugin logic goes here.&lt;/span&gt;
};

$.fn.plugin.defaults = {
    param1: &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;,
    param2: &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;,
    param3: &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Здесь мы вручную выносим дефолтные настройки в метод функции, пользуясь тем, что функция — это объект.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$.widget&lt;/code&gt; позволяет это делать даже проще:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;ns.plugin&quot;&lt;/span&gt;, {

    &lt;span class=&quot;comment&quot;&gt;// Default options.&lt;/span&gt;
    options: {
        param1: &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;,
        param2: &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;,
        param3: &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;
    },

    &lt;span class=&quot;comment&quot;&gt;// Этот методы вызовется при первом обращении к виджету: $('div').widgetName();&lt;/span&gt;
    _create: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;comment&quot;&gt;// Options are already merged and stored in this.options&lt;/span&gt;
        &lt;span class=&quot;comment&quot;&gt;// Plugin logic goes here.&lt;/span&gt;
    }

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мы из коробки имеем смерженные дефолтные и юзерские параметры и доступ к ним извне.&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Методы&lt;/h1&gt;
&lt;p&gt;После инициализации виджета мы можем следить за его состоянием, менять его и выполнять с помощью виджета какие-то 
действия. Выполнить действие — запустить метод. Метод запускается так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Геттер&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Сеттер (передали параметр)&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// При таком вызове метода (а-ля плагин) виджет возвращает jQuery object, так что можно&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// продолжать цепочку вызовов:&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; )
    .progressbar( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt; )
    .addClass( &lt;span class=&quot;string&quot;&gt;&quot;almost-done&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Общие методы&lt;/h2&gt;
&lt;p&gt;Некоторые методы идут из коробки.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;option&lt;/strong&gt; позволяет установить параметр после инициализации виджета:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Получить значение (геттер)&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;option&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Установить значение (сеттер)&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;option&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Перезаписать сразу несколько параметров&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;option&quot;&lt;/span&gt;, {
    value: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,
    disabled: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Получение и установка значений следует синтаксису jQuery core. Например, &lt;code&gt;$(&amp;#39;div&amp;#39;).css()&lt;/code&gt;. Отличие в том, что в 
виджет передается еще одни параметр — имя метода.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;disable&lt;/strong&gt; — метод для отключения виджета. Например, прогрессбар становится серым и перестает изменяться.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;disable&quot;&lt;/span&gt; );
$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;option&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;disabled&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Эквивалентный синтаксис&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;enable&lt;/strong&gt; — метод включения виджета (выключение отключения &amp;uarr;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;enable&quot;&lt;/span&gt; );
$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;option&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;disabled&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Эквивалентный синтаксис&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;destroy&lt;/strong&gt; — грохнуть виджет, закончить его жизненный цикл:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;destroy&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После удаления виджета работать с ним нельзя. Надо работать — инициализируем заново. При вызове &lt;code&gt;.remove()&lt;/code&gt; у 
элемента виджета, при изменении &lt;code&gt;.html()&lt;/code&gt; или вызове &lt;code&gt;.empty()&lt;/code&gt; у родителей &lt;code&gt;destroy&lt;/code&gt; вызывается автоматически.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;widget&lt;/strong&gt; вернет сгенерированную виджетом разметку. Если таковой нет, то вернется исходный элемент:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar( &lt;span class=&quot;string&quot;&gt;&quot;widget&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;События&lt;/h1&gt;
&lt;p&gt;Видеты могут триггерить события при изменении состояния. Обычно к именам событияй виджета добавляется префикс — 
название виджета:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;progressbarchange&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    alert( &lt;span class=&quot;string&quot;&gt;&quot;The value has changed!&quot;&lt;/span&gt; );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Каждому событию соответствует коллбэк, который мы можем переопределить:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#elem&quot;&lt;/span&gt; ).progressbar({
    change: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        alert( &lt;span class=&quot;string&quot;&gt;&quot;The value has changed!&quot;&lt;/span&gt; );
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Общие события&lt;/h2&gt;
&lt;p&gt;У всех виджетов уже есть событие &lt;code&gt;create&lt;/code&gt;, которое сработает при создании виджета.&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Написание виджета&lt;/h1&gt;
&lt;p&gt;Рассмотрим написание виджета на примере &lt;a href=&quot;http://jqueryui.com/progressbar/&quot;&gt;прогрессбара&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В метод &lt;code&gt;$.widget&lt;/code&gt; передается 2 параметра: имя плагина и объект с его функционалом. Widget factory создаст 
конструктор и будет использовать переданный объект как прототип для него. Весь дефолтный функционал будет браться из 
&lt;code&gt;jQuery.Widget.prototype&lt;/code&gt;. У плагина контекст (&lt;code&gt;this&lt;/code&gt;) — это DOM-элемент, у виджета контекст — единичный экземпляр 
объекта:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;nmk.progressbar&quot;&lt;/span&gt;, { &lt;span class=&quot;comment&quot;&gt;// nmk — namespace, progressbar - widget name&lt;/span&gt;

    _create: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; progress = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value + &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.addClass( &lt;span class=&quot;string&quot;&gt;&quot;progressbar&quot;&lt;/span&gt; ).text( progress );
    }

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;При создании, экземпляр виджета сохраняется в &lt;code&gt;.data&lt;/code&gt; DOM-объекта:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = $( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div /&amp;gt;&quot;&lt;/span&gt;)
    .appendTo( &lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt; )
    .progressbar()
    .data( &lt;span class=&quot;string&quot;&gt;&quot;nmk-progressbar&quot;&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Call a method directly on the plugin instance.&lt;/span&gt;
bar.option( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Access properties on the plugin instance.&lt;/span&gt;
alert( bar.options.value );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Widget Factory позволяет работать с прототипом всех созданных сущностей. Добавляя новые методы, они становятся 
доступны всем эзкемплярам:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.nmk.progressbar.prototype.reset = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._setOption( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; );
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Соглашения&lt;/h2&gt;
&lt;p&gt;Пространство имен: имя плагина начинается с неймспейса, далее следует точка и после точки идет имя плагина:
&lt;code&gt;nmk.progressbar&lt;/code&gt;. Неймспейс &lt;code&gt;ui&lt;/code&gt; занят компонентами библиотеки jQuery UI. Нам следует использовать свое собственное 
пространство имен.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.element&lt;/code&gt; — объект jQuery (единичный). Если Widget Factory, вызывается на коллекции элементов, то для каждого 
элемента создается &lt;em&gt;свой собственный&lt;/em&gt; экземляр. Эти экземпляры унаследуют методы и свойства от одного прототипа.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.options&lt;/code&gt; — объект с опциями, которые переданы при инициализации.&lt;/p&gt;
&lt;p&gt;Значения по умолчанию (опции и коллбэки) мы можем обозначить как объект &lt;code&gt;options&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;nmk.progressbar&quot;&lt;/span&gt;, {

    &lt;span class=&quot;comment&quot;&gt;// Default options.&lt;/span&gt;
    options: {
        value: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,

        callback: &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// Callbacks are also here&lt;/span&gt;
    },

    _create: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; progress = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value + &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.addClass( &lt;span class=&quot;string&quot;&gt;&quot;progressbar&quot;&lt;/span&gt; ).text( progress );
    }

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Widget factory предоставляет удобные способ управления состоянием плагина и соглашение по выполнению частых задач, 
типа работы с приватными и внешними методами.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Добавление методов&lt;/h2&gt;
&lt;p&gt;Мы можем добавить методы в наш объект, в том числе приватные, начав их имена с подчеркивания. Снаружи они будут 
недоступны:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;nmk.progressbar&quot;&lt;/span&gt;, {
    options: {
        value: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;
    },

    _create: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; progress = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value + &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.addClass(&lt;span class=&quot;string&quot;&gt;&quot;progressbar&quot;&lt;/span&gt;).text( progress );
    },

    &lt;span class=&quot;comment&quot;&gt;// Create a public method.&lt;/span&gt;
    value: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; value &lt;/span&gt;) &lt;/span&gt;{

        &lt;span class=&quot;comment&quot;&gt;// No value passed, act as a getter.&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( value === &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt; ) {

            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value;

        &lt;span class=&quot;comment&quot;&gt;// Value passed, act as a setter.&lt;/span&gt;
        } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {

            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._constrain( value );
            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; progress = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value + &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;;
            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.text( progress );

        }

    },

    &lt;span class=&quot;comment&quot;&gt;// Create a private method.&lt;/span&gt;
    _constrain: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; value &lt;/span&gt;) &lt;/span&gt;{

        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( value &amp;gt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; ) {
            value = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;
        }

        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( value &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ) {
            value = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
        }

        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;
    }

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для вызова методов нужно передать параметр в виджет. Если нужно установить значение, то передаем его следом:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = $( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div /&amp;gt;&quot;&lt;/span&gt; ).appendTo( &lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt;).progressbar({ value: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; });

&lt;span class=&quot;comment&quot;&gt;// Get the current value.&lt;/span&gt;
alert( bar.progressbar( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt; ) );

&lt;span class=&quot;comment&quot;&gt;// Update the value.&lt;/span&gt;
bar.progressbar( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Get the current value again.&lt;/span&gt;
alert( bar.progressbar( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt; ) );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Это не самый удобный способ работы. Так сделано для того, чтобы по-минимуму воздействовать своими методами на объект 
&lt;code&gt;$&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Работа с опциями&lt;/h2&gt;
&lt;p&gt;Widget Factory предоставляет возможность работы с опциями. С помощью метода &lt;code&gt;option()&lt;/code&gt; можно получать и устанавливать
опции после инициализации используя его как геттер и сеттер. В него можно передавать единичные мараметры или срзау 
объект.&lt;/p&gt;
&lt;p&gt;При установке опций вызывается метод &lt;code&gt;_setOption&lt;/code&gt; для каждого передаваемого свойства. Этот метод мы можем указать 
руками, чтобы контролировать установку опций.&lt;/p&gt;
&lt;p&gt;Если нам нужно что-то сделать со всей пачкой передаваемых опций, в нашем распоряжении имеетс метод &lt;code&gt;_setOptions&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;custom.progressbar&quot;&lt;/span&gt;, {
    options: {
        value: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;
    },
    _create: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._constrain(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value);
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.addClass( &lt;span class=&quot;string&quot;&gt;&quot;progressbar&quot;&lt;/span&gt; );
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.refresh();
    },
    _setOption: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; key, value &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( key === &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt; ) {
            value = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._constrain( value );
        }
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._super( key, value );
    },
    _setOptions: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; options &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._super( options );
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.refresh();
    },
    refresh: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; progress = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value + &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.text( progress );
    },
    _constrain: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; value &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( value &amp;gt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; ) {
            value = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;
        }
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( value &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ) {
            value = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
        }
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;callbacks&quot;&gt;Callbacks&lt;/h2&gt;
&lt;p&gt;Для того, чтобы реагировать на изменение состояния нашего виджета предусмотрен механизм работы с колбэк-функциями. В 
прмере ниже с помощью метода &lt;code&gt;_trigger&lt;/code&gt; вызывается метод &lt;code&gt;complete&lt;/code&gt;, который сработает, когда значение прогрессбара 
достигнет 100%.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;custom.progressbar&quot;&lt;/span&gt;, {
    options: {
        value: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;
    },
    _create: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._constrain(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value);
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.addClass( &lt;span class=&quot;string&quot;&gt;&quot;progressbar&quot;&lt;/span&gt; );
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.refresh();
    },
    _setOption: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; key, value &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( key === &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt; ) {
            value = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._constrain( value );
        }
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._super( key, value );
    },
    _setOptions: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; options &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._super( options );
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.refresh();
    },
    refresh: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; progress = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value + &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.text( progress );
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value == &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; ) {
            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._trigger( &lt;span class=&quot;string&quot;&gt;&quot;complete&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, { value: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; } ); &lt;span class=&quot;comment&quot;&gt;// вызов колбэка и триггеринг события&lt;/span&gt;
        }
    },
    _constrain: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; value &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( value &amp;gt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; ) {
            value = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;
        }
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( value &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ) {
            value = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
        }
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Метод &lt;code&gt;_trigger&lt;/code&gt; принимает 3 параметра: имя колбэка, объект события jQuery и объект данных. Колбэк-функция — это один
из параметров. Ее можно получать и вызывать как обычные опции. На ряду с колбэк-функций триггериться и событие. Имя 
события получается из объединения имени виджета и колбэк-функции: &lt;code&gt;progressbarcomplete&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = $( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;&lt;/span&gt; )
    .appendTo( &lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt; )
    .progressbar({
        complete: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; event, data &lt;/span&gt;) &lt;/span&gt;{
            alert( &lt;span class=&quot;string&quot;&gt;&quot;Callbacks are great!&quot;&lt;/span&gt; );
        }
    })
    .bind( &lt;span class=&quot;string&quot;&gt;&quot;progressbarcomplete&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; event, data &lt;/span&gt;) &lt;/span&gt;{
        alert( &lt;span class=&quot;string&quot;&gt;&quot;Events bubble and support many handlers for extreme flexibility.&quot;&lt;/span&gt; );
        alert( &lt;span class=&quot;string&quot;&gt;&quot;The progress bar value is &quot;&lt;/span&gt; + data.value );
    });

bar.progressbar( &lt;span class=&quot;string&quot;&gt;&quot;option&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-widget-factory&quot;&gt;Как работает Widget Factory&lt;/h1&gt;
&lt;p&gt;Вызов &lt;code&gt;$.widget(&amp;#39;namespace.widgetname&amp;#39;, widgetObject)&lt;/code&gt; создает конструктор и устанавливает его прототипом 
передаваемый &lt;code&gt;widgetObject&lt;/code&gt;. Таким образом все создаваемые сущности унаследуют от &lt;code&gt;widgetObject&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Сам объект унаследует дефолтный функционал от &lt;code&gt;jQuery.Widget.prototype&lt;/code&gt; (Widget с большой буквы).&lt;/p&gt;
&lt;p&gt;Для примера можно рассмотреть &lt;a href=&quot;http://jqueryui.com/resources/demos/progressbar/default.html&quot;&gt;http://jqueryui.com/resources/demos/progressbar/default.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Запустив в консоли &lt;code&gt;$.ui.progressbar.prototype&lt;/code&gt; можно увидеть объект, от которого виджет наследует методы и свойства
присущие ему из коробки.&lt;/p&gt;
&lt;p&gt;При создании виджета ссылка на его объект содержится в &lt;code&gt;jQuery.data&lt;/code&gt; DOM-элемента. На той же странице можно 
посмотреть &lt;code&gt;$( &amp;quot;#progressbar&amp;quot; ).data(&amp;#39;uiProgressbar&amp;#39;)&lt;/code&gt; и его &lt;code&gt;__proto__&lt;/code&gt;. А раз так, то мы можем записать ее в 
переменную и обращаться к методам и свойсвтам через точку, а не передавая в скобках названия:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = $( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;&lt;/span&gt; )
    .appendTo( &lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt; )
    .progressbar()                 &lt;span class=&quot;comment&quot;&gt;// Инициализировали виджет&lt;/span&gt;
    .data( &lt;span class=&quot;string&quot;&gt;&quot;custom-progressbar&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Достали и сохранили в bar ссылку на объект виджета&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Call a method directly on the plugin instance.&lt;/span&gt;
bar.option( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Access properties on the plugin instance.&lt;/span&gt;
alert( bar.options.value );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Так же можно вызывать конструктор виджета напрямую:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = $.custom.progressbar({},       &lt;span class=&quot;comment&quot;&gt;// возможные опции&lt;/span&gt;
    $( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;&lt;/span&gt; ).appendTo( &lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// элемент виджета&lt;/span&gt;
);

&lt;span class=&quot;comment&quot;&gt;// Same result as before.&lt;/span&gt;
alert( bar.options.value );
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Добавление/изменение методов в прототипе виджета&lt;/h2&gt;
&lt;p&gt;Поскольку в виджете мы работаем с конструктором и прототипом (в плагине мы не имеем таких возможностей), то мы можем 
легко расширять его функционал: добавлять новые методы или изменять существующие:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Добавим метод для сбрасывания значения прогрессбара&lt;/span&gt;
$.custom.progressbar.prototype.reset = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._setOption( &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; );
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;Дестрой&lt;/h1&gt;
&lt;p&gt;Для того, чтобы удалить виджет и почистить за собой существует метод &lt;code&gt;_destroy&lt;/code&gt;. Из коробки он удаляет ссылку на 
объект из &lt;code&gt;jQuery.data&lt;/code&gt; элемента, отключает все события из неймспейса виджета.&lt;/p&gt;
&lt;p&gt;Метод &lt;code&gt;_destroy()&lt;/code&gt; вызывается с помощью открытого метода &lt;code&gt;destroy()&lt;/code&gt;. Мы сами можем добавить в него нужный функционал:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;custom.progressbar&quot;&lt;/span&gt;, {
    options: {
        value: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;
    },
    _create: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._constrain(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value);
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.addClass( &lt;span class=&quot;string&quot;&gt;&quot;progressbar&quot;&lt;/span&gt; );
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.refresh();
    },
    _setOption: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; key, value &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( key === &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt; ) {
            value = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._constrain( value );
        }
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._super( key, value );
    },
    _setOptions: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; options &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._super( options );
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.refresh();
    },
    refresh: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; progress = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value + &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.text( progress );
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.options.value == &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; ) {
            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._trigger( &lt;span class=&quot;string&quot;&gt;&quot;complete&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, { value: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; } );
        }
    },
    _constrain: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; value &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( value &amp;gt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; ) {
            value = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;
        }
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( value &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ) {
            value = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
        }
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;
    },
    _destroy: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element
            .removeClass( &lt;span class=&quot;string&quot;&gt;&quot;progressbar&quot;&lt;/span&gt; )
            .text( &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; );
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;Особенности вызова методов&lt;/h1&gt;
&lt;p&gt;Widget factory создает и плагин и экземпляр объекта. Мы можем вызывать методы используя эти два подхода.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Вызов метода из плагина&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;.selector&quot;&lt;/span&gt; ).dialog( &lt;span class=&quot;string&quot;&gt;&quot;close&quot;&lt;/span&gt; );
$( &lt;span class=&quot;string&quot;&gt;&quot;.selector&quot;&lt;/span&gt; ).dialog( &lt;span class=&quot;string&quot;&gt;&quot;option&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;height&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// вызов метода с параметром (получаем высоту)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Вызов метода из объекта&lt;/h2&gt;
&lt;p&gt;По скольку каждый экземпляр каждого виджета храниться в &lt;code&gt;jQuery.data&lt;/code&gt;, то мы можем просто доставать методы по ссылке:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dialog = $( &lt;span class=&quot;string&quot;&gt;&quot;.selector&quot;&lt;/span&gt; ).data( &lt;span class=&quot;string&quot;&gt;&quot;ui-dialog&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// сохраняем ссылку на объект&lt;/span&gt;
dialog.close(); &lt;span class=&quot;comment&quot;&gt;// вызываем методы напрямую&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Можно и так, с помощью метода &lt;code&gt;instance&lt;/code&gt; (работает в jQuery UI 1.11):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;.selector&quot;&lt;/span&gt; ).dialog( &lt;span class=&quot;string&quot;&gt;&quot;instance&quot;&lt;/span&gt; ).close();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Возвращаемые значения&lt;/h2&gt;
&lt;p&gt;Когда мы используем вызов метода как из плагина, то возвращается jQuery-объект и мы можем продолжить цепочку. 
Исключение — методы, которые возвращают информацию о состоянии виджета:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dialog = $( &lt;span class=&quot;string&quot;&gt;&quot;.selector&quot;&lt;/span&gt; ).dialog();

&lt;span class=&quot;comment&quot;&gt;// Plugin invocation - returns a jQuery object&lt;/span&gt;
dialog.dialog( &lt;span class=&quot;string&quot;&gt;&quot;close&quot;&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Therefore, plugin method invocation makes it possible to&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// chain method calls with other jQuery functions&lt;/span&gt;
dialog.dialog( &lt;span class=&quot;string&quot;&gt;&quot;close&quot;&lt;/span&gt; )
    .css( &lt;span class=&quot;string&quot;&gt;&quot;color&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Запрашиваем информацию о состоянии виджета. jQuery-объект не вернется:&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;.selector&quot;&lt;/span&gt; )
    .dialog( &lt;span class=&quot;string&quot;&gt;&quot;isOpen&quot;&lt;/span&gt; )
    &lt;span class=&quot;comment&quot;&gt;// This will throw a TypeError&lt;/span&gt;
    .css( &lt;span class=&quot;string&quot;&gt;&quot;color&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Когда мы вызываем метод из экземпляра, то вернется &lt;code&gt;undefined&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Instance invocation - returns undefined&lt;/span&gt;
dialog.data( &lt;span class=&quot;string&quot;&gt;&quot;ui-dialog&quot;&lt;/span&gt; ).close();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;Расширение функционала существующих виджетов&lt;/h1&gt;
&lt;p&gt;Иногда нужно что-то подкрутить в существующем виджете или сделано новый на его основе. Обычно виджеты создаются 
фукнций &lt;code&gt;$.wiget&lt;/code&gt;, которая получает два параметра: название виджета с нейспейсом и прототипный объект. Однако, если 
передать вторым параметром конструктор другого виджета, то он будет взят за основу:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;custom.superDialog&quot;&lt;/span&gt;, {} );              &lt;span class=&quot;comment&quot;&gt;// создание нового виджета без наследования&lt;/span&gt;
$.widget( &lt;span class=&quot;string&quot;&gt;&quot;custom.superDialog&quot;&lt;/span&gt;, $.ui.dialog, {} ); &lt;span class=&quot;comment&quot;&gt;// за основу будет взят $.ui.dialog&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В объекте, который передается третьим параметром мы можем переопределять или задавать собственные методы:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;custom.superDialog&quot;&lt;/span&gt;, $.ui.dialog, {
    red: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.element.css( &lt;span class=&quot;string&quot;&gt;&quot;color&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt; );
    }
});

&lt;span class=&quot;comment&quot;&gt;// Create a new &amp;lt;div&amp;gt;, convert it into a superDialog, and call the red() method.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;I am red&amp;lt;/div&amp;gt;&quot;&lt;/span&gt; )
    .superDialog()
    .superDialog( &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Расширение существующим методов&lt;/h2&gt;
&lt;p&gt;Если в новом виджете создать метод с названием таким же, как у родительского, то мы его просто перетрем:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;custom.superDialog&quot;&lt;/span&gt;, $.ui.dialog, {
    open: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;// Был такой метод в $.ui.dialog, теперь его нету, только вывод в консоль&lt;/span&gt;
        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;open&quot;&lt;/span&gt; );
    }
});

&lt;span class=&quot;comment&quot;&gt;// Create a new &amp;lt;div&amp;gt;, and convert it into a superDialog.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;&quot;&lt;/span&gt; ).superDialog();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Зачастую нам не нужно переписывать существующие мтоды, нам нужно их расширять. Это можно сделать с помощью методов 
&lt;code&gt;_super()&lt;/code&gt; и &lt;code&gt;_superApply()&lt;/code&gt;, которые вызовут одноименный метод из прототипного объекта:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;custom.superDialog&quot;&lt;/span&gt;, $.ui.dialog, {
    open: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;open&quot;&lt;/span&gt; );

        &lt;span class=&quot;comment&quot;&gt;// Invoke the parent widget's open(). Теперь все будет работать.&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._super();
    }
});

$( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;&quot;&lt;/span&gt; ).superDialog();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;_super&lt;/code&gt; и &lt;code&gt;_superApply&lt;/code&gt; отличаются так же, как &lt;code&gt;call()&lt;/code&gt; и &lt;code&gt;apply()&lt;/code&gt; для функций: первый получает список аргументов, 
второй — массив аргументов.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;custom.superDialog&quot;&lt;/span&gt;, $.ui.dialog, {
    _setOption: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; key, value &lt;/span&gt;) &lt;/span&gt;{

        &lt;span class=&quot;comment&quot;&gt;// Both invoke dialog's setOption() method. _super() requires the arguments&lt;/span&gt;
        &lt;span class=&quot;comment&quot;&gt;// be passed as an argument list, _superApply() as a single array.&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._super( key, value );
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._superApply( &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt; );
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Переопределение виджетов&lt;/h2&gt;
&lt;p&gt;Мы можем полностью переопределить виджет (не создавая новый) задав такое же имя, как и у прототипа:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.widget( &lt;span class=&quot;string&quot;&gt;&quot;ui.dialog&quot;&lt;/span&gt;, $.ui.dialog, { &lt;span class=&quot;comment&quot;&gt;// Не будем создавать новый, будем расширять текущий&lt;/span&gt;
    open: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;open&quot;&lt;/span&gt; );
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._super();
    }
});

$( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;&quot;&lt;/span&gt; ).dialog();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Переопределение методов в отдельных экземплярах&lt;/h2&gt;
&lt;p&gt;Для этого пользуемся обычной JS-нотацией для объектов:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dialogInstance = $( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;&quot;&lt;/span&gt; )
    .dialog()
    .data( &lt;span class=&quot;string&quot;&gt;&quot;ui-dialog&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Retrieve the dialog's instance and store it.&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Override the close() method for this dialog&lt;/span&gt;
dialogInstance.close = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;close&quot;&lt;/span&gt; );
};

&lt;span class=&quot;comment&quot;&gt;// Create a second dialog&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;&quot;&lt;/span&gt; ).dialog();

&lt;span class=&quot;comment&quot;&gt;// Select both dialogs and call close() on each of them.&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// &quot;close&quot; will only be logged once.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;:data(ui-dialog)&quot;&lt;/span&gt; ).dialog( &lt;span class=&quot;string&quot;&gt;&quot;close&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;Материалы&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.jquery.com/jquery-ui/&quot;&gt;https://learn.jquery.com/jquery-ui/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/plugins/stateful-plugins-with-widget-factory/&quot;&gt;http://learn.jquery.com/plugins/stateful-plugins-with-widget-factory/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.jqueryui.com/jQuery.widget&quot;&gt;http://api.jqueryui.com/jQuery.widget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://devdocs.magento.com/guides/v2.0/coding-standards/code-standard-jquery-widgets.html&quot;&gt;http://devdocs.magento.com/guides/v2.0/coding-standards/code-standard-jquery-widgets.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ajpiano.com/widgetfactory&quot;&gt;http://ajpiano.com/widgetfactory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/magentodev/take-more-from-jquery&quot;&gt;http://www.slideshare.net/magentodev/take-more-from-jquery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;-homework-&quot;&gt;Домашняя работа &lt;a href=&quot;http://amiskov.github.io/learn/articles/jquery-widget-factory/#homework&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Задача — реализовать список с выделением, используя Widget Factory.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Клик на элементе списка выделяет только его.&lt;/li&gt;
&lt;li&gt;Ctrl (Cmd) + клик добавляет/убирает элемент из выделенных. &lt;/li&gt;
&lt;li&gt;Shift + клик добавляет промежуток от последнего кликнутого к выделению. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/learn/articles/jquery-widget-factory/wf_homework.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Нужно реализовать API виджета, чтобы можно было получить массив индексов выделенных элементов, выделить все элементы 
и снять выделение полностью.&lt;/p&gt;
&lt;p&gt;Не забываем про деструктор. Нужно дать возможность разработчикам почистить за собой, когда виджет будет не нужен.&lt;/p&gt;
&lt;p&gt;Обратите внимание на работу с событиями и метод &lt;a href=&quot;http://api.jqueryui.com/jQuery.widget/#method-_on&quot;&gt;&lt;code&gt;_on&lt;/code&gt;&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Возможно, пригодиться вспомнить некоторые &lt;a href=&quot;http://learn.javascript.ru/css-selectors&quot;&gt;CSS-селекторы&lt;/a&gt;, но можно и без 
них. &lt;/p&gt;
&lt;p&gt;Примерный код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; selectable = $(&lt;span class=&quot;string&quot;&gt;'#currencies'&lt;/span&gt;).selectable({
    selected: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;e, data&lt;/span&gt;) &lt;/span&gt;{
        $(&lt;span class=&quot;string&quot;&gt;'#selectedItems'&lt;/span&gt;).text(data.selectedItems.join(&lt;span class=&quot;string&quot;&gt;', '&lt;/span&gt;));
    }
}).data(&lt;span class=&quot;string&quot;&gt;'am-selectable'&lt;/span&gt;);

&lt;span class=&quot;comment&quot;&gt;// selectable.someMethod('someParameter');&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// selectable.destroy();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>jQuery Plugins</title>
      <link>http://amiskov.github.io/learn//learn/articles/jquery-plugins/</link>
      <pubDate>Thu, 03 Sep 2015 10:30:00 +0300</pubDate>
      <guid isPermaLink="true">http://amiskov.github.io/learn//learn/articles/jquery-plugins/</guid>
      <author></author>
      <description>&lt;p&gt;Плагин — это что-то, что расширяет существующий функционал. jQuery работает с DOM, Ajax и имеет раяд утилит. Если нам
нужно расширить существующие возможности, то можно написать плагин.&lt;/p&gt;
&lt;p&gt;По этому материалу есть &lt;a href=&quot;http://amiskov.github.io/learn/articles/jquery-plugins/#-homework-&quot;&gt;домашнее задание&lt;/a&gt;.
&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Плагин jQuery — это новый метод в объекте jQuery.prototype. Добавляя метод (создавая плагин), мы делаем его доступным
всем jQuery-объектам:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $element = $(&lt;span class=&quot;string&quot;&gt;'&amp;lt;div&amp;gt;'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// Унаследует все методы jQuery.prototype&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Задача плагина — работать с коллекцией элементов (что-то с ней делать). Например, &lt;code&gt;fadeOut&lt;/code&gt;, &lt;code&gt;addClass&lt;/code&gt; и пр.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jQuery.fn&lt;/code&gt; это то же самое, что &lt;code&gt;jQuery.prototype&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Где-то в районе 92-й строки исходника jQuery&lt;/span&gt;
jQuery.fn = jQuery.prototype = {
    &lt;span class=&quot;comment&quot;&gt;// The current version of jQuery being used&lt;/span&gt;
    jquery: version,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Подробнее о &lt;a href=&quot;http://amiskov.github.io/learn/articles/jquery-plugins/learn.jquery.com/plugins/&quot;&gt;прототипах в JS&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Простейший плагин&lt;/h1&gt;
&lt;h2 id=&quot;-1-jquery&quot;&gt;Шаг 1: добавление метода в прототип jQuery&lt;/h2&gt;
&lt;p&gt;Чтобы создать плагин, нужно добавить метод в прототип jQuery. При вызове этого метода на коллекции его &lt;code&gt;this&lt;/code&gt; как 
раз и бдует этой коллекцией. Соответственно, в нем доступны все методы &lt;code&gt;jQuery.prototype&lt;/code&gt; (например, &lt;code&gt;.css&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.fn.makeItRed = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.dir(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);
    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.css(&lt;span class=&quot;string&quot;&gt;'color'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'red'&lt;/span&gt;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-2-&quot;&gt;Шаг 2: обеспечение цепочного вызова&lt;/h2&gt;
&lt;p&gt;Чтобы над jQuery-коллекцией можно было работать и после вызова нашего плагина, нужно вернуть &lt;code&gt;this&lt;/code&gt;. Так мы обеспечим
работоспособность дальнейших вызовов в цепочке:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.fn.makeItRed = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.css(&lt;span class=&quot;string&quot;&gt;'color'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'red'&lt;/span&gt;);
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;
};
$(&lt;span class=&quot;string&quot;&gt;'p'&lt;/span&gt;).makeItRed().makeItBig();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-3-&quot;&gt;Шаг 3: ограничение области видимости&lt;/h2&gt;
&lt;p&gt;Разные библиотеки любят использовать &lt;code&gt;$&lt;/code&gt; для своих нужд. Чтобы не получилось конфликта, мы должны ограничить доступ к
нашему методу извне. Завернем наш код в функциональное выражение:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt; $ &lt;/span&gt;) &lt;/span&gt;{

    $.fn.makeItRed = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.css( &lt;span class=&quot;string&quot;&gt;&quot;color&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt; );
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;
    };

}( jQuery ));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь внутри функционального выражения мы можем создавать переменные с любыми именами и не бояться, что они будут 
использованы во внешнем коде:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt; $ &lt;/span&gt;) &lt;/span&gt;{

    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; shade = &lt;span class=&quot;string&quot;&gt;&quot;#556b2f&quot;&lt;/span&gt;;

    $.fn.greenify = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.css( &lt;span class=&quot;string&quot;&gt;&quot;color&quot;&lt;/span&gt;, shade );
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;
    };

}( jQuery ));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Подробнее об ограничении области видимости:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.javascript.ru/closures-module&quot;&gt;Модули через замыкания&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Immediately-Invoked Function Expression (IIFE)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;-4-&quot;&gt;Шаг 4: минимизация присутствия&lt;/h2&gt;
&lt;p&gt;Плагин должен иметь минимальное вхождение в прототип. Например, если мы делаем попап, то у него будут методы для 
закрытия и открытия. Сходу можно попробовать сделать нечто подобное:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Два метода для одного плагина. Плохо.&lt;/span&gt;
(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; $ &lt;/span&gt;) &lt;/span&gt;{

    $.fn.openPopup = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;comment&quot;&gt;// Open popup code.&lt;/span&gt;
    };

    $.fn.closePopup = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;comment&quot;&gt;// Close popup code.&lt;/span&gt;
    };

}( jQuery ));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В примере выше в прототип добавляется 2 метода. Так делать не стоит. Лучше добавить один и передавать в него параметры:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; $ &lt;/span&gt;) &lt;/span&gt;{

    $.fn.popup = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; action &lt;/span&gt;) &lt;/span&gt;{

        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( action === &lt;span class=&quot;string&quot;&gt;&quot;open&quot;&lt;/span&gt;) {
            &lt;span class=&quot;comment&quot;&gt;// Open popup code.&lt;/span&gt;
        }

        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( action === &lt;span class=&quot;string&quot;&gt;&quot;close&quot;&lt;/span&gt; ) {
            &lt;span class=&quot;comment&quot;&gt;// Close popup code.&lt;/span&gt;
        }

    };

}( jQuery ));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Это хороший подход для плагина, но это выглядит не красиво с точки зрения ООП. Попап — это объект. У объекта должны быть 
методы, а мы тут передаем какие-то параметры. Однако, так принято в мире jQuery, этот подход оправдан и хорошо 
работает если дело касается расширения существующего функционала.&lt;/p&gt;
&lt;p&gt;Как вариант, в этом случае попап, можно сделать объектом и создавать экземпляры через конструктор или воспользоваться
&lt;a href=&quot;http://amiskov.github.io/learn/articles/jquery-widget-factory&quot;&gt;jQuery widget factory&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-5-&quot;&gt;Шаг 5: Перебор элементов коллекции&lt;/h2&gt;
&lt;p&gt;При инициализации плагин получает коллекцию элементов jQuery. Это массив объектов DOM, расширенный методами jQuery.
Если нужно делать что-то с каждым элементом коллекции, то ее можно перебрать с помощью &lt;code&gt;.each()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;$.fn.myNewPlugin = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.each(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;comment&quot;&gt;// Do something to each element here.&lt;/span&gt;
    });

};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В этом примере возвращается результат перебора. Это тот же &lt;code&gt;this&lt;/code&gt;, поэтому нет смысла возвращать &lt;code&gt;this&lt;/code&gt; отдельно.&lt;/p&gt;
&lt;h2 id=&quot;-6-&quot;&gt;Шаг 6: опции&lt;/h2&gt;
&lt;p&gt;Часто нам хочется передавать в плагин какие-то параметры (опции). Для этого используют переопределение объекта с 
опциями по умолчанию:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt; $ &lt;/span&gt;) &lt;/span&gt;{

    $.fn.greenify = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; options &lt;/span&gt;) &lt;/span&gt;{

        &lt;span class=&quot;comment&quot;&gt;// This is the easiest way to have default options.&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; settings = $.extend({
            &lt;span class=&quot;comment&quot;&gt;// These are the defaults.&lt;/span&gt;
            color: &lt;span class=&quot;string&quot;&gt;&quot;#556b2f&quot;&lt;/span&gt;,
            backgroundColor: &lt;span class=&quot;string&quot;&gt;&quot;white&quot;&lt;/span&gt;
        }, options );

        &lt;span class=&quot;comment&quot;&gt;// Greenify the collection based on the settings variable.&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.css({
            color: settings.color,
            backgroundColor: settings.backgroundColor
        });

    };

}( jQuery ));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Пример&lt;/h2&gt;
&lt;p&gt;Плагин, который собирает все ссылки и ставит рядом в скобочках их href:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; $ &lt;/span&gt;) &lt;/span&gt;{

    $.fn.showLinkLocation = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{

        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.filter( &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt; ).append(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot; (&quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.href + &lt;span class=&quot;string&quot;&gt;&quot;)&quot;&lt;/span&gt;;
        });

        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;

    };

}( jQuery ));
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;Более продвинутые техники&lt;/h1&gt;
&lt;h2 id=&quot;-&quot;&gt;Доступ к дефолтным настройкам&lt;/h2&gt;
&lt;p&gt;Чтобы разработчики могли установить свое собственное значение по умолчанию и не переопределять его постоянно, нужно 
сделать объект опций свойством функции плагина:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Plugin definition.&lt;/span&gt;
$.fn.highlight = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; options &lt;/span&gt;) &lt;/span&gt;{

    &lt;span class=&quot;comment&quot;&gt;// Extend our default options with those provided.&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;// Note that the first argument to extend is an empty&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;// object – this is to keep from overriding our &quot;defaults&quot; object.&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; opts = $.extend( {}, $.fn.highlight.defaults, options );

    &lt;span class=&quot;comment&quot;&gt;// Our plugin implementation code goes here.&lt;/span&gt;

};

&lt;span class=&quot;comment&quot;&gt;// Plugin defaults – added as a property on our plugin function.&lt;/span&gt;
$.fn.highlight.defaults = {
    foreground: &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;,
    background: &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь можно сделать так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Override plugin default foreground color.&lt;/span&gt;
$.fn.highlight.defaults.foreground = &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;;

&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Invoke plugin using new defaults.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;.highlightDiv&quot;&lt;/span&gt; ).highlight();

&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Override default by passing options to plugin method.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#green&quot;&lt;/span&gt; ).highlight({
    foreground: &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Предоставить доступ к прикладным функциям&lt;/h2&gt;
&lt;p&gt;Это даст возможность минимальными усилиями изменить поведение плаина:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Plugin definition.&lt;/span&gt;
$.fn.highlight = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; options &lt;/span&gt;) &lt;/span&gt;{

    &lt;span class=&quot;comment&quot;&gt;// Iterate and reformat each matched element.&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.each(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{

        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; elem = $( &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; );

        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;

        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; markup = elem.html();

        &lt;span class=&quot;comment&quot;&gt;// Call our format function.&lt;/span&gt;
        markup = $.fn.highlight.format( markup );

        elem.html( markup );

    });

};

&lt;span class=&quot;comment&quot;&gt;// Define our format function.&lt;/span&gt;
$.fn.highlight.format = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; txt &lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;strong&amp;gt;&quot;&lt;/span&gt; + txt + &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;/strong&amp;gt;&quot;&lt;/span&gt;;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Здесь разработчик сможет переопределить шаблон итоговой разметки на свой собственный. Написать плагин для нашего 
плагина.&lt;/p&gt;
&lt;p&gt;Для примера можно взглянуть на код плагина &lt;a href=&quot;/learn/articles/jquery-plugins/jquery.cycle.js&quot;&gt;jQuery Cycle 2&lt;/a&gt;. Там таких методов много. Напирмер, один
из них — &lt;code&gt;transitions&lt;/code&gt; — отвечает за эффекты. Такая организация кода позволяет удобно делать &lt;a href=&quot;http://malsup.com/jquery/cycle2/download/advanced.php&quot;&gt;расширения для 
плагина&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Ограничить доступ к служебным функциям&lt;/h2&gt;
&lt;p&gt;Открывая доступ к методам, мы, тем самым, обязуемся поддерживать определенную совместимость в будущем. Изменим 
название метода, как-то решим реорганизовать наш код — нарушим совместимость. Таким образом, если нет уверенности, 
что какой-то метод нужно открыть, то лучше оставить его приватным. Это можно сделать через замыкание, обернув код в 
анонимную функцию с вызовом на месте:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create closure.&lt;/span&gt;
(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; $ &lt;/span&gt;) &lt;/span&gt;{

    &lt;span class=&quot;comment&quot;&gt;// Plugin definition.&lt;/span&gt;
    $.fn.highlight = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; options &lt;/span&gt;) &lt;/span&gt;{
        debug( &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; );
        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
    };

    &lt;span class=&quot;comment&quot;&gt;// Private function for debugging.&lt;/span&gt;
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; obj &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.console &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.console.log ) {
            &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.console.log( &lt;span class=&quot;string&quot;&gt;&quot;highlight selection count: &quot;&lt;/span&gt; + obj.length );
        }
    };

    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// End of closure.&lt;/span&gt;

})( jQuery );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Метод &lt;code&gt;debug&lt;/code&gt; останется только внутри функции и будет браться внутренним кодом из замыкания.&lt;/p&gt;
&lt;!--
## Ответственная кастомизация

## Не изобретать свой собственный синтаксис

## Дать возможность изменять разметку

## Дать возможность указывать коллбэк-функции

При написании плагина нужно всегда иметь ввиду 3 вещи:
* Гибкость
* Размер
* Производительность
--&gt;
&lt;h1 id=&quot;-&quot;&gt;Материалы&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/plugins/&quot;&gt;http://learn.jquery.com/plugins/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://remysharp.com/2010/06/03/signs-of-a-poorly-written-jquery-plugin&quot;&gt;Признаки плохого плагина&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/#jquerypluginpatterns&quot;&gt;jQuery Plugin Design Patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;-homework-&quot;&gt;Домашняя работа &lt;a href=&quot;http://amiskov.github.io/learn/articles/jquery-plugins/#homework&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Написать плагин, который позволит сортировать содержимое таблиц по столбцам. Пример решения:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/learn/articles/jquery-plugins/homework/table-sortable/sortable.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Для сортировки значений используется метод &lt;code&gt;.sort&lt;/code&gt; &lt;a href=&quot;http://learn.javascript.ru/array-methods#сортировка-метод-sort-fn&quot;&gt;массива&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Сортировать нужно 2 вида значений: строки и числа. Для этого в таблице предусмотрены соответствющие атрибуты:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;thead&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;th&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;data-type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;string&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Имя&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;th&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;th&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;data-type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;number&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Возраст&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;th&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;th&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;data-type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;string&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Город&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;th&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;thead&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;tbody&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;Вася&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;5&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;Смоленск&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;tbody&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;elixir&quot;&gt;
&lt;span class=&quot;variable&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;'table'&lt;/span&gt;).sortable();
&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Сортировку можно сделать только по возрастанию. Если сделаете сортировку и по убыванию, это будет очень хорошо.&lt;/p&gt;
&lt;div class=&quot;homework-tip&quot;&gt;
&lt;span class=&quot;homework-tip__handle&quot;&gt;Подсказка&lt;/span&gt;
&lt;div class=&quot;homework-tip__content&quot;&gt;
&lt;ol&gt;
&lt;li&gt;Для начала &lt;a href=&quot;http://learn.javascript.ru/array-methods#сортировка-метод-sort-fn&quot;&gt;изучите&lt;/a&gt;, как работает 
метод &lt;code&gt;sort&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Создайте из строк таблицы массив, его нужно будет отсортировать.&lt;/li&gt;
&lt;li&gt;Напишите свою сортировочную функцию для метода &lt;code&gt;sort&lt;/code&gt;, которая бы получала для сравнения две строки таблицы, 
доставала бы из них нужные значения и сравнивала бы их между собой. Если этот пункт не понятен, см. пункт №1.&lt;/li&gt;
&lt;li&gt;Отсортируйте массив строк и вставье их в таблицу.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    <item>
      <title>jQuery Ajax</title>
      <link>http://amiskov.github.io/learn//learn/articles/jquery-ajax/</link>
      <pubDate>Thu, 27  Aug 2015 10:30:00 +0300</pubDate>
      <guid isPermaLink="true">http://amiskov.github.io/learn//learn/articles/jquery-ajax/</guid>
      <author></author>
      <description>&lt;p&gt;Объект &lt;code&gt;XMLHttpRequest&lt;/code&gt; позволяет браузеру обращаться к серверу без перезагрузки страницы. Посылается асинхронный запрос
на URL, сервер отдает данные, котоыре можно обработать в коллбэк-функции. Асинхронный — значит не блокирующий. То 
есть остальной код может продолжать исполняться во время выполнения запроса. Асинхронные запросы требуют времени на 
выполнение и могут быть обработаны не сразу. Для этого используются коллбэки и некоторые другие штуки.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Так работать не будет:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; response;

    $.get( &lt;span class=&quot;string&quot;&gt;&quot;foo.php&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; r &lt;/span&gt;) &lt;/span&gt;{
        response = r;
    });

    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( response ); &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А так будет:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;    $.get( &lt;span class=&quot;string&quot;&gt;&quot;foo.php&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; response &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( response ); &lt;span class=&quot;comment&quot;&gt;// server response&lt;/span&gt;
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ajax — Asynchronous JavaScript and XML. Однако, XML тут по историческим причинам. В основном обмен данными происходит
в формате [JSON][2] или просто HTML.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Кроссдоменные запросы&lt;/h2&gt;
&lt;p&gt;Раньше браузеры не позволяли делать посылать ajax-запросы на другие домены. Обходной путь — JSONP. Запросы 
осуществляются через тег &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;. Современные браузеры используют [Cross-Origin Resource Sharing (CORS)][1].&lt;/p&gt;
&lt;p&gt;Чтобы аякс-запрос обработался, клиент и сервер должны быть на одном домене, использовать одни и тот же протокол 
(http/https) и общаться по одному и тому же порту. Это ограничение не распространяется на скрпты, загружаемые через 
аяксовые методы jQuery.&lt;/p&gt;
&lt;p&gt;JSNP обходит эти ограничения, релазиуя передачу данных, которые будут записаны в тег &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;. Сервер возвращает 
скрипт, который будет обернут в коллбэк-функцию, которую мы ему назовем.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&quot;http://caniuse.com/#search=CORS&quot;&gt;http://caniuse.com/#search=CORS&lt;/a&gt;
[2] &lt;a href=&quot;http://json.org/json-ru.html&quot;&gt;http://json.org/json-ru.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Основные понятия&lt;/h2&gt;
&lt;h3 id=&quot;get-post&quot;&gt;GET и POST&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;GET&lt;/code&gt;-запрос нужен для получения данных. Не для изменения или удаления, а просто для того, чтобы что-то узнать. Такие
запросы кешируются браузерами и посылаются как параметры в адресной строке браузера.
Например, &lt;code&gt;https://www.google.ru/webhp?sourceid=chrome-instant&amp;amp;ion=1&amp;amp;espv=2&amp;amp;ie=UTF-8#q=json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POST&lt;/code&gt;-запросы используются для изменения данных на сервере: добавить пользователя, удалить товар, изменить пароль и 
пр. Такие запросы браузер не кеширует и данные не видны в адресной строке.&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;Типы данных&lt;/h3&gt;
&lt;p&gt;Данные могут быть получены в разном виде:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;text — обычные строковые данные&lt;/li&gt;
&lt;li&gt;html — блоки html-кода&lt;/li&gt;
&lt;li&gt;script — для добавления нового тега script на страницу&lt;/li&gt;
&lt;li&gt;JSON — передача строк, массивов и объектов&lt;/li&gt;
&lt;li&gt;JSONP — JSON с другого домена&lt;/li&gt;
&lt;li&gt;XML&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В основном используется JSON.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Методы для работы с аяксом&lt;/h2&gt;
&lt;p&gt;Основной функционал в jQuery реализует метод &lt;code&gt;$.ajax&lt;/code&gt;. Остальные методы — шорткаты.&lt;/p&gt;
&lt;p&gt;Рекомендуется использовать синтаксис &lt;code&gt;$.ajax&lt;/code&gt; для любых запросов (?).&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Работа с формами&lt;/h2&gt;
&lt;h2 id=&quot;-&quot;&gt;Сериализация&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;serialize()&lt;/code&gt; — представляет данные формы в виде строки запроса (query string). Каждый элемент формы должен иметь 
атрибут &lt;code&gt;name&lt;/code&gt;. Значения инпутов &lt;code&gt;checkbox&lt;/code&gt; и &lt;code&gt;radio&lt;/code&gt; добавятся только если они отмечены.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Turning form data into a query string&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#myForm&quot;&lt;/span&gt; ).serialize();

&lt;span class=&quot;comment&quot;&gt;// Creates a query string like this:&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// field_1=something&amp;amp;field2=somethingElse&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;serializeArray&lt;/code&gt; — представляет данные формы в виде массива объектов:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Creating an array of objects containing form data&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#myForm&quot;&lt;/span&gt; ).serializeArray();

&lt;span class=&quot;comment&quot;&gt;// Creates a structure like this:&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// [&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//   {&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//     name : &quot;field_1&quot;,&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//     value : &quot;something&quot;&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//   },&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//   {&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//     name : &quot;field_2&quot;,&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//     value : &quot;somethingElse&quot;&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//   }&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// ]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Валидация&lt;/h2&gt;
&lt;h2 id=&quot;-&quot;&gt;Префильтер&lt;/h2&gt;
&lt;h2 id=&quot;jsonp&quot;&gt;JSONP&lt;/h2&gt;
&lt;p&gt;Создается тег скрипт, в src добавляется нужный URL. Начинается загрузка. Сервер отдает данные, обернутые в 
функцию-коллбэк. Название функции заранее оговорено, все о нем знают. Клиент полностью доверяет серверу:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Добавляем скрипт&lt;/span&gt;
addScript(&lt;span class=&quot;string&quot;&gt;'user?id=123&amp;amp;callback=onUserData'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// функция сгенерирует &amp;lt;script src=&quot;user?id=...&quot;&amp;gt; и добавить в head&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// ответ сервера&lt;/span&gt;
onUserData({
  name: &lt;span class=&quot;string&quot;&gt;&quot;Вася&quot;&lt;/span&gt;,
  age: &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Материалы&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.jquery.com/ajax/&quot;&gt;https://learn.jquery.com/ajax/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.javascript.ru/json&quot;&gt;http://learn.javascript.ru/json&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.javascript.ru/ajax-jsonp&quot;&gt;http://learn.javascript.ru/ajax-jsonp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.jquery.com/category/ajax/&quot;&gt;http://api.jquery.com/category/ajax/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/&quot;&gt;http://www.html5rocks.com/en/tutorials/cors/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>Работа с событиями в jQuery</title>
      <link>http://amiskov.github.io/learn//learn/articles/jquery-events/</link>
      <pubDate>Thu, 20  Aug 2015 10:30:00 +0300</pubDate>
      <guid isPermaLink="true">http://amiskov.github.io/learn//learn/articles/jquery-events/</guid>
      <author></author>
      <description>&lt;p&gt;Синтаксис, делегирование, создание событий, способы вызова и пр. По этому материалу есть &lt;a href=&quot;http://amiskov.github.io/learn/articles/jquery-events/#-homework-&quot;&gt;домашнее задание&lt;/a&gt;
&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;obtrusive-vs-unobtrusive&quot;&gt;Obtrusive vs. Unobtrusive&lt;/h2&gt;
&lt;p&gt;Так делать нельзя:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    &amp;lt;button onclick=&lt;span class=&quot;string&quot;&gt;&quot;alert('Hello')&quot;&lt;/span&gt;&amp;gt;Say hello&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/button&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Плохо поддерживать&lt;/li&gt;
&lt;li&gt;Плохо расширять &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Нужно пользоваться только ивент-листнерами, хоть в Мадженте много где используются обработчики в атрибутах.&lt;/p&gt;
&lt;h2 id=&quot;this&quot;&gt;this&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; внутри функции обработчика — это кликнутый элемент. Функция получает объект события.&lt;/p&gt;
&lt;h2 id=&quot;-on&quot;&gt;.on&lt;/h2&gt;
&lt;p&gt;Основной способ навесить события — &lt;code&gt;.on()&lt;/code&gt;. У него есть удобные алиасы: &lt;code&gt;.click()&lt;/code&gt;, &lt;code&gt;.blur()&lt;/code&gt; и т. д. Некоторые из 
них позволяют обработать похожие события минимальными усилиями. Например, &lt;code&gt;.hover()&lt;/code&gt;
&lt;a href=&quot;https://api.jquery.com/hover/&quot;&gt;может сразу&lt;/a&gt; взять на себя &lt;code&gt;mouseenter&lt;/code&gt; и &lt;code&gt;mouseleave&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#menu li&quot;&lt;/span&gt; ).hover(
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        $( &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; ).css( {
             background: &lt;span class=&quot;string&quot;&gt;'red'&lt;/span&gt;
         });
     },
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
        $( &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; ).css( {
             background: &lt;span class=&quot;string&quot;&gt;''&lt;/span&gt;
         });
     }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если в &lt;code&gt;.hover()&lt;/code&gt; передать одну функцию, то она сработает и на &lt;code&gt;mouseenter&lt;/code&gt; и на &lt;code&gt;mouseleave&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Сами &lt;code&gt;jQuery&lt;/code&gt; &lt;a href=&quot;http://learn.jquery.com/events/introduction-to-events/#ways-to-listen-for-events&quot;&gt;рекомендуют&lt;/a&gt; всегда 
использовать &lt;code&gt;.on&lt;/code&gt;, потому что так работает быстрее и код выглядит более консистентно (всегда однотипен).&lt;/p&gt;
&lt;p&gt;Через &lt;code&gt;.on()&lt;/code&gt; можно:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;обработать разные события одной и той же функцией&lt;/li&gt;
&lt;li&gt;передать данные в функцию обработчик&lt;/li&gt;
&lt;li&gt;работать с кастомными событиями&lt;/li&gt;
&lt;li&gt;или передать объект нескольких событий и обработчиков&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;.on()&lt;/code&gt; будет работать на элементах, которые уже существуют в документе на момент назначения. Новые аналогичные&lt;br&gt;элементы не будут иметь этого обработчика.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Неймспейсы событий&lt;/h2&gt;
&lt;p&gt;Для того, чтобы снимать события пачками, можно им добавлять неймспейсы:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$(&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;).on(&lt;span class=&quot;string&quot;&gt;'mousemove.slider'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{});
$(&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;).on(&lt;span class=&quot;string&quot;&gt;'mouseup.slider'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{});
&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
$(&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;).off(&lt;span class=&quot;string&quot;&gt;'.slider'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// Снять все события в неймспейсе&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Удаление обработчиков&lt;/h2&gt;
&lt;p&gt;Удалить можно все обработчики события:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;'p'&lt;/span&gt;).off(&lt;span class=&quot;string&quot;&gt;'click'&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Или все события из неймспейса:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Создаем&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;click.myNamespace&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt; } );
$( &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;mouseenter.myNamespace&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt; } );
&lt;span class=&quot;comment&quot;&gt;// Удаляем&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt; ).off( &lt;span class=&quot;string&quot;&gt;&quot;click.myNamespace&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Только клики&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt; ).off( &lt;span class=&quot;string&quot;&gt;&quot;.myNamespace&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Unbind all events in the namespace&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Удалить можно и обработчик, назначенный через именованную функцию:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; foo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{ &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; ); };
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bar = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{ &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; ); };
$( &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;click&quot;&lt;/span&gt;, foo ).on( &lt;span class=&quot;string&quot;&gt;&quot;click&quot;&lt;/span&gt;, bar );
$( &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt; ).off( &lt;span class=&quot;string&quot;&gt;&quot;click&quot;&lt;/span&gt;, bar ); &lt;span class=&quot;comment&quot;&gt;// foo is still bound to the click event&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Исполнить событие только раз&lt;/h2&gt;
&lt;p&gt;Если нужно, чтобы событие сработало только один раз, а потом перестало работать или обработчик при последующих таких 
же событиях был другим, можно использовать &lt;code&gt;.one()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Это бывает полезно, если нужно при первом действии выполнить какую-то инициализацию, которая сохраниться для 
последующих манипуляций. Напирмер, сгеренить разметку для выпадалки кастомного селекта при первом клике и назначить 
на него обработчики для последующих кликов. Если на него так ни разу и не кликнули, то и делать ничего не будем: DOM 
не засоряем, ивенты не навешиваем.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/learn/articles/jquery-events/examples/one.html&quot;&gt;Пример&lt;/a&gt; сработает отдельно для каждого параграфа:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt; ).one( &lt;span class=&quot;string&quot;&gt;&quot;click&quot;&lt;/span&gt;, firstClick );
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;firstClick&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;You just clicked this for the first time!&quot;&lt;/span&gt; );
    $( &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; ).click( &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{ &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;You have clicked this before!&quot;&lt;/span&gt; ); } );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если в обработчик навесить сразу на несколько событий, то он будет работать для каждого события в отдельности:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;input[id]&quot;&lt;/span&gt; ).one( &lt;span class=&quot;string&quot;&gt;&quot;focus mouseover keydown&quot;&lt;/span&gt;, firstEvent);
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;firstEvent&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; eventObject &lt;/span&gt;) &lt;/span&gt;{
   &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;A &quot;&lt;/span&gt; + eventObject.type + &lt;span class=&quot;string&quot;&gt;&quot; event occurred for the first time on the input with id &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.id );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Делегирование&lt;/h2&gt;
&lt;p&gt;Есть 2 вида синтаксиса, работают инентично. Первый, где передается объект, в котором событие — свойство:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt; ).on({
    click: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; event &lt;/span&gt;) &lt;/span&gt;{
        alert( &lt;span class=&quot;string&quot;&gt;&quot;Hello.&quot;&lt;/span&gt; );
    }
}, &lt;span class=&quot;string&quot;&gt;&quot;button&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И второй, где событие — строка:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;click&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;button&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; event &lt;/span&gt;) &lt;/span&gt;{
    alert( &lt;span class=&quot;string&quot;&gt;&quot;Hello.&quot;&lt;/span&gt; );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Именованные функции-обработчики&lt;/h2&gt;
&lt;p&gt;Нужно помнить, что &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;повторять код — плохо&lt;/a&gt;. Если какие-то 
действия нужно производить для разных событий, то лучше вынести обработчик в отдельную функцию вместо анонимной. Эта 
функция получит объект события:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHello&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; event &lt;/span&gt;) &lt;/span&gt;{
    alert( &lt;span class=&quot;string&quot;&gt;&quot;Hello.&quot;&lt;/span&gt; );
}
$( &lt;span class=&quot;string&quot;&gt;&quot;#helloBtn&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;click&quot;&lt;/span&gt;, sayHello );
$( &lt;span class=&quot;string&quot;&gt;&quot;#helloLink&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;click&quot;&lt;/span&gt;, sayHello );
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Объект события&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/learn/articles/jquery-events/examples/event_object.html&quot;&gt;Расширенный объект события&lt;/a&gt; передается в функцию-обработчик. Он содиржит &lt;code&gt;event
.originalEvent&lt;/code&gt; — 
событие, которое генерит сам браузер (может быть иногда полезно, например, для тач-устройств).&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Передача данных&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;click&quot;&lt;/span&gt;, {
    foo: &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;
}, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; event &lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;event data: &quot;&lt;/span&gt; + event.data.foo + &lt;span class=&quot;string&quot;&gt;&quot; (should be 'bar')&quot;&lt;/span&gt; );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Несколько событий, один обработчик&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/learn/articles/jquery-events/examples/multiple_events.html&quot;&gt;Пример&lt;/a&gt;
Так будет оптимальнее, потому что экономятся ресурсы (?): &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;mouseenter mouseleave&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;mouse hovered over or left a div&quot;&lt;/span&gt; );
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( e.type == &lt;span class=&quot;string&quot;&gt;'mouseenter'&lt;/span&gt;) { ... }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Несколько событий, много обработчиков&lt;/h2&gt;
&lt;p&gt;Так более читаемо, но создаются методы, которые можно и не создавать:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    $( &lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt; ).on({
        mouseenter: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
            &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;hovered over a div&quot;&lt;/span&gt; );
        },
        mouseleave: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
            &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;mouse left a div&quot;&lt;/span&gt; );
        },
        click: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
            &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;clicked on a div&quot;&lt;/span&gt; );
        }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Вызов события из кода&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.trigger()&lt;/code&gt; позволяет имитировать событие на элементе с обработчиком &lt;code&gt;.on&lt;/code&gt;. Оне работает только с 
jQuery-обработчиками, нативные событие триггерить так не получится:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&amp;lt;a href=&quot;http://learn.jquery.com&quot;&amp;gt;Learn jQuery&amp;lt;/a&amp;gt;
&amp;lt;script&amp;gt;
    // Ничего не произойдет
    $( &quot;a&quot; ).trigger( &quot;click&quot; );
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для лучшей читаемости кода, если нужно передать какие-то данные вместе с вызовом события, рекомендуется использовать 
расширенный синтаксис:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt; ).trigger({
  type: &lt;span class=&quot;string&quot;&gt;&quot;logged&quot;&lt;/span&gt;,
  user: &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;,
  pass: &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если надо вызвать нативное событие, то можно воспользоваться &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/createEvent&quot;&gt;document.createEvent&lt;/a&gt;.
Есть еще плагин &lt;a href=&quot;https://github.com/jquery/jquery-simulate/&quot;&gt;jquery.simulate&lt;/a&gt;. Он триггерит и нативные и jQuery-события.&lt;/p&gt;
&lt;h3 id=&quot;-trigger-vs-triggerhandler-&quot;&gt;.trigger() vs .triggerHandler()&lt;/h3&gt;
&lt;p&gt;Отличия:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Запуск дефолтных обработчиков браузера (не те, которые мы пишем, а внутренние, типа сабмита формы).
&lt;code&gt;triggerHandler&lt;/code&gt; их не запустит, &lt;code&gt;trigger&lt;/code&gt; запустит.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Запуск обработчика на коллекции:
&lt;code&gt;triggerHandler&lt;/code&gt; запустит только на первом элементе, &lt;code&gt;trigger&lt;/code&gt; запустит на всех элементах коллекции.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Возвращаемое значение:
&lt;code&gt;triggerHandler&lt;/code&gt; вернет результат обработчика, &lt;code&gt;trigger&lt;/code&gt; вернет элемент, на котором сработало событие (можно 
использовать в цепочке).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Всплытие:
&lt;code&gt;triggerHandler&lt;/code&gt; не запускает всплытие, &lt;code&gt;trigger&lt;/code&gt; запустит всплытие, сработают обработчики на парентах.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Вывод: используем &lt;code&gt;triggerHandler&lt;/code&gt;, если не нужны фишки &lt;code&gt;trigger&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Триггер события для запуска какого-то функционала&lt;/strong&gt;
Так делать не рекомендуется. Если, например, на клик кнопки показывается попап, а нам его нужно показать программно, то
не стоит просто триггерить событие на первой кнопке, для показа попапа. Нужно вынести этот код в отдельную функцию и 
запускать отдельно.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/learn/articles/jquery-events/examples/triggers.html&quot;&gt;Пример&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Triggering an event handler the right way&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; foo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; event &lt;/span&gt;) &lt;/span&gt;{
   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( event ) {
       &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( event );
   } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
       &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;this didn't come from an event!&quot;&lt;/span&gt; );
   }
};
$( &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt; ).on( &lt;span class=&quot;string&quot;&gt;&quot;click&quot;&lt;/span&gt;, foo );
foo(); &lt;span class=&quot;comment&quot;&gt;// instead of $( &quot;p&quot; ).trigger( &quot;click&quot; )&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Кастомные события&lt;/h2&gt;
&lt;p&gt;Событийно-ориентированный подход к реализации интерфейсов сменяет фокус с элемента, который событие запускает, на 
элемент, на котором оно срабатывает (над которым выполняется действие).&lt;/p&gt;
&lt;p&gt;Преимущества:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Один раз пишем код для поведения, триггерим его из разным мест столько, сколько нужно.&lt;/li&gt;
&lt;li&gt;За один подход можно запустить обработчик для разных, похожих и одиночных элементов (?)&lt;/li&gt;
&lt;li&gt;Код закреплен за целевым элементом (а не за тем, который запускает обработку), таким образом код проще поддерживать.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В чистом JS есть конструктор &lt;code&gt;CustomEvent&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-homework-&quot;&gt;Домашнее задание &lt;a href=&quot;http://amiskov.github.io/learn/articles/jquery-events/#homework&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Имеется объект с названиями регионов и их идентификаторами:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; regions = {
    &lt;span class=&quot;number&quot;&gt;485&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Москва&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;523&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Владимирская область&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;530&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Калужская область&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;536&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Ленинградская область&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;486&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Московская область&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;549&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Рязанская область&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;563&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Санкт-Петербург&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;554&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Смоленская область&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;556&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Тверская область&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;558&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Тульская область&quot;&lt;/span&gt;,
    &lt;span class=&quot;number&quot;&gt;562&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Ярославская область&quot;&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Нужно написать компонент — кастомный селект, который получает этот объект и индентификатор текущего региона (он 
должен быть выбран по в селекте по умолчанию).&lt;/p&gt;
&lt;p&gt;Пример инициализации:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; select = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Select(regions, selectedId);

&lt;span class=&quot;comment&quot;&gt;// Компонент должен генерировать событие после смены региона:&lt;/span&gt;
select.on(&lt;span class=&quot;string&quot;&gt;'change'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;{
    alert(e.value);
});

$(&lt;span class=&quot;string&quot;&gt;'#regions'&lt;/span&gt;).append(select.getElement());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Примерный вид и работа компонента. Выбор региона из списка и по клику на кнопке:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/learn/articles/jquery-events/homework/custom-select.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Никаких ограничений на внешний вид и синтаксис нет, делайте как считаете нужным. Главное, чтоб код был понятен и 
удобен в использовании.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Материалы&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/events/&quot;&gt;http://learn.jquery.com/events/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.jquery.com/category/events/&quot;&gt;http://api.jquery.com/category/events/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.javascript.ru/widgets&quot;&gt;https://learn.javascript.ru/widgets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.javascript.ru/task/custom-select&quot;&gt;https://learn.javascript.ru/task/custom-select&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>Ядро jQuery</title>
      <link>http://amiskov.github.io/learn//learn/articles/jquery-core/</link>
      <pubDate>Thu, 06  Aug 2015 10:30:00 +0300</pubDate>
      <guid isPermaLink="true">http://amiskov.github.io/learn//learn/articles/jquery-core/</guid>
      <author></author>
      <description>&lt;p&gt;Обзор основного функционала jQuery.
&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!--
# Случаи, когда лушче не использовать jQuery
Основная задача jQuery — обеспечить кроссбраузерность. Современные браузеры (возьмем IE9+) в этом плане лучше своих 
предсшественников и многие возможности в ES5 реализованы нативно и работают быстрее, чем аналоги jQuery.

В основном нативный функционал лучше использовать вместо утилитарныйх методов jQuery.

## $.each
Для массивов есть свйо `forEach` (IE9+).

## $.inArray
Для массивов есть свой `indexOf` (IE9+).

## Материалы
* http://youmightnotneedjquery.com/ — набор аналогов jQuery-методам на нативном JS и DOM.
* http://kangax.github.io/compat-table/es5/ — таблица совместимости ES5.
--&gt;
&lt;h1 id=&quot;jquery-object-&quot;&gt;jQuery Object ($)&lt;/h1&gt;
&lt;p&gt;При работе с DOM разные браузеры могут вести себя по-разному. jQuery берет на себя проблемы совместимости и
предоставляет удобные методы работы с элементами.&lt;/p&gt;
&lt;p&gt;При создании и выборке элементов функция &lt;code&gt;$&lt;/code&gt; возвращает расширенную коллекцию элементов. Индексы идут с 0, имеется 
свойство &lt;code&gt;length&lt;/code&gt; и ряд методов, похожих на методы массивов.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Проверка коллекции на пустоту&lt;/h2&gt;
&lt;p&gt;jQuery в любом случае вернет коллекцию, а она всегда будет &lt;code&gt;true&lt;/code&gt; при преобразованию у булевому значению. Поэтому при
проверке коллекции на пустоту нужно смотреть на свойство &lt;code&gt;.length&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $sections = $( &lt;span class=&quot;string&quot;&gt;'section'&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// BROKEN CODE:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ($sections) { alert( &lt;span class=&quot;string&quot;&gt;'Test'&lt;/span&gt; ); } &lt;span class=&quot;comment&quot;&gt;// всегда сработает, пустой массив вернет true&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// OK&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ($sections.length) { alert( &lt;span class=&quot;string&quot;&gt;'Test'&lt;/span&gt; ); } &lt;span class=&quot;comment&quot;&gt;// сработает только когда есть элементы section&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Изменение коллекции и изменение документа&lt;/h2&gt;
&lt;p&gt;jQuery коллекции — не «живые», как &lt;code&gt;getElementsByName&lt;/code&gt; и &lt;code&gt;getElementsByClassName&lt;/code&gt;. Выборка запоминается и, если в 
html произошли изменения, то ее надо переопределить.&lt;/p&gt;
&lt;h2 id=&quot;-eq-get-&quot;&gt;Выбор элемента, eq() и get()&lt;/h2&gt;
&lt;p&gt;Если из коллекции нам нужно выбрать определенный элемент, мы можем выбрать его по индексу:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $headings = $( &lt;span class=&quot;string&quot;&gt;'h1'&lt;/span&gt; );
$headings.eq(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// вернет первый элемент из коллекции, jQuery object&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если нам нужно выбртаь не расширенный эелмент, а обычный DOM-элемент, то можно воспользоваться методом &lt;code&gt;get()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$headings.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// вернет первый элемент из коллекции, но уже как DOM object&lt;/span&gt;
$headings.[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];    &lt;span class=&quot;comment&quot;&gt;// аналогично, вернет DOM object&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Таким образом, коллекция jQuery — это псевдо-массив DOM-элементов и куча методов, наследованных от объекта jQuery. 
Это можно увидеть в консоли:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.dir( $headings );        &lt;span class=&quot;comment&quot;&gt;// псевдо-массив DOM-объектов&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( $headings.eq(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) );  &lt;span class=&quot;comment&quot;&gt;// псевдо-массив с одним DOM-объектом&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( $headings.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) ); &lt;span class=&quot;comment&quot;&gt;// один DOM-объект&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-jquery&quot;&gt;Сравнение объектов jQuery&lt;/h2&gt;
&lt;p&gt;Каждый расширенный jQuery-объект уникален. Даже если объекты сделаны из одного селектора, они не равны.&lt;/p&gt;
&lt;p&gt;Чтобы в коде было четко видно, где jQuery объекты, а где простые DOM-объекты и переменные, к jQuery-выборкам 
добавляют префикс &lt;code&gt;$&lt;/code&gt;: &lt;code&gt;var $title = $(&amp;#39;h1&amp;#39;)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-vs-&quot;&gt;$ vs. $()&lt;/h2&gt;
&lt;p&gt;Можно встретить методы, типа &lt;code&gt;$.each()&lt;/code&gt; и &lt;code&gt;$(&amp;#39;ul&amp;#39;).each&lt;/code&gt;. Они принадлежать к разным областям jQuery.&lt;/p&gt;
&lt;p&gt;Методы, которые вызываются через &lt;code&gt;$.&lt;/code&gt; — утилиты jQuery. Могут возвращать разные вещи.&lt;/p&gt;
&lt;p&gt;Методы, которые работают с селекторами (&lt;code&gt;$(&amp;#39;ul&amp;#39;)&lt;/code&gt;), получают и возвращают коллекцию как &lt;code&gt;this&lt;/code&gt;. Они принадлежат к 
области видимости &lt;code&gt;$.fn&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$.fn&lt;/code&gt; — “jQuery prototype”. Методы объектов jQuery, работают с коллекциями элементов.&lt;/p&gt;
&lt;h2 id=&quot;-id-css-&quot;&gt;Выбор элемента с id, в котором содержатся символы из CSS-нотации (точки и двоеточия)&lt;/h2&gt;
&lt;p&gt;В этом случае точки и двоеточия экранируются двумя слешами:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// BROKEN CODE&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;'some:id'&lt;/span&gt; ); $( &lt;span class=&quot;string&quot;&gt;'some.id'&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// А так нормально:&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;'some\\:id'&lt;/span&gt; ); $( &lt;span class=&quot;string&quot;&gt;'some\\.id'&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Материалы&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/using-jquery-core/jquery-object/&quot;&gt;http://learn.jquery.com/using-jquery-core/jquery-object/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/using-jquery-core/dollar-object-vs-function/&quot;&gt;http://learn.jquery.com/using-jquery-core/dollar-object-vs-function/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/&quot;&gt;http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;-css-&quot;&gt;.css()&lt;/h1&gt;
&lt;p&gt;С помощью метода &lt;code&gt;.css()&lt;/code&gt; можно получить значение css-свойства, установить его или установить пачку css-свойств:&lt;/p&gt;
&lt;p&gt;Получить значение css-свойства:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; ).css( &lt;span class=&quot;string&quot;&gt;&quot;fontSize&quot;&lt;/span&gt; );  &lt;span class=&quot;comment&quot;&gt;// Returns a string such as &quot;19px&quot;.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; ).css( &lt;span class=&quot;string&quot;&gt;&quot;font-size&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Also works.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Установить значение css-свойства (свойств):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; ).css( &lt;span class=&quot;string&quot;&gt;&quot;fontSize&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;100px&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Setting an individual property.&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Setting multiple properties.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; ).css({
    fontSize: &lt;span class=&quot;string&quot;&gt;&quot;100px&quot;&lt;/span&gt;,
    color: &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;При передаче в метод &lt;code&gt;.css()&lt;/code&gt; свойства должны быть в виде camelCase (&lt;code&gt;fontSize: &amp;quot;10px&amp;quot;&lt;/code&gt;) или в виде строки 
(&lt;code&gt;&amp;quot;font-size&amp;quot;: &amp;quot;10px&amp;quot;&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Не стоит пользоватьсы методом css для установки стилей. Лучше все делать через классы, так будет работать быстрее.&lt;/p&gt;
&lt;h2 id=&quot;-css-&quot;&gt;Использование CSS-классов&lt;/h2&gt;
&lt;p&gt;Внешний вид элементов нужно задавать через CSS-классы. JS не должен отвечать за визуальное представление. Поэтому 
метод &lt;code&gt;.css()&lt;/code&gt; нормально использовать как геттер, но как сеттер его лучше не применять.&lt;/p&gt;
&lt;p&gt;Для работы с классами имеются методы &lt;code&gt;.addClass()&lt;/code&gt;, &lt;code&gt;.removeClass()&lt;/code&gt;, &lt;code&gt;.toggleClass()&lt;/code&gt;. Наличие класса можно проверить
при помощи метода &lt;code&gt;.hasClass()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; h1 = $( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; );

h1.addClass( &lt;span class=&quot;string&quot;&gt;&quot;big&quot;&lt;/span&gt; );
h1.removeClass( &lt;span class=&quot;string&quot;&gt;&quot;big&quot;&lt;/span&gt; );
h1.toggleClass( &lt;span class=&quot;string&quot;&gt;&quot;big&quot;&lt;/span&gt; );

&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( h1.hasClass( &lt;span class=&quot;string&quot;&gt;&quot;big&quot;&lt;/span&gt; ) ) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-data&quot;&gt;Методы для работы с data&lt;/h1&gt;
&lt;p&gt;Часто нужно вместе с элементом хранить какие-то данные о нем. Для этого в jQuery есть специальные методы:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#myDiv&quot;&lt;/span&gt; ).data( &lt;span class=&quot;string&quot;&gt;&quot;keyName&quot;&lt;/span&gt;, { foo: &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; } ); &lt;span class=&quot;comment&quot;&gt;// сохранить объект в свойство keyName&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;#myDiv&quot;&lt;/span&gt; ).data( &lt;span class=&quot;string&quot;&gt;&quot;keyName&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// Returns { foo: &quot;bar&quot; }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Таким образом за элементом можно закрепить &lt;em&gt;любой&lt;/em&gt; вид данных. В том числе и ссылки на другие элементы.&lt;/p&gt;
&lt;p&gt;Например, нам нужно установить связь между элементом списка и дивом внутри него. Чтобы каждый раз не дергать DOM, 
можно сохранить референс однажды и потом по нему доставать нужный див:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#myList li&quot;&lt;/span&gt; ).each(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{

    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; li = $( &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; );
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; div = li.find( &lt;span class=&quot;string&quot;&gt;&quot;div.content&quot;&lt;/span&gt; );

    li.data( &lt;span class=&quot;string&quot;&gt;&quot;contentDiv&quot;&lt;/span&gt;, div );
});

&lt;span class=&quot;comment&quot;&gt;// Теперь нам не нужно находить див в DOM, можно просто достать его из data&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; firstLi = $( &lt;span class=&quot;string&quot;&gt;&quot;#myList li:first&quot;&lt;/span&gt; );
firstLi.data( &lt;span class=&quot;string&quot;&gt;&quot;contentDiv&quot;&lt;/span&gt; ).html( &lt;span class=&quot;string&quot;&gt;&quot;new content&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Так же можно передать сразу пачку data-свойств:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$el.data({
    &lt;span class=&quot;string&quot;&gt;'str'&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;'Hello'&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'bool'&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;'arr'&lt;/span&gt;: [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],
    &lt;span class=&quot;string&quot;&gt;'obj'&lt;/span&gt;: { isOk: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;Работа с размерами элемента&lt;/h1&gt;
&lt;p&gt;Basic dimensions methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Sets the width of all &amp;lt;h1&amp;gt; elements.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; ).width( &lt;span class=&quot;string&quot;&gt;&quot;50px&quot;&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Gets the width of the first &amp;lt;h1&amp;gt; element.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; ).width();

&lt;span class=&quot;comment&quot;&gt;// Sets the height of all &amp;lt;h1&amp;gt; elements.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; ).height( &lt;span class=&quot;string&quot;&gt;&quot;50px&quot;&lt;/span&gt; );

&lt;span class=&quot;comment&quot;&gt;// Gets the height of the first &amp;lt;h1&amp;gt; element.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; ).height();


&lt;span class=&quot;comment&quot;&gt;// Returns an object containing position information for&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// the first &amp;lt;h1&amp;gt; relative to its &quot;offset (positioned) parent&quot;.&lt;/span&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;h1&quot;&lt;/span&gt; ).position();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;Материалы&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/using-jquery-core/css-styling-dimensions/&quot;&gt;CSS, Styling &amp;amp; Dimensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.jquery.com/category/dimensions/&quot;&gt;Category: Dimensions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;-index-&quot;&gt;Получение индекса элемента или свойства, .index()&lt;/h1&gt;
&lt;p&gt;Метод &lt;code&gt;.index()&lt;/code&gt; можно вызывать четырьмя способами и вести он будет себя по-разному. Если &lt;code&gt;.index()&lt;/code&gt; вызывается над 
коллекцией, то берется первый элемент.&lt;/p&gt;
&lt;h2 id=&quot;1-index-&quot;&gt;1. Использование .index() без аргументов&lt;/h2&gt;
&lt;p&gt;При вызове без аргументов вернется индекс объекта (от нуля) в коллекции:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;test&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;test 1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;test 2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;test 3&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $test = $(&lt;span class=&quot;string&quot;&gt;'li#test'&lt;/span&gt;);
$test.index(); &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; 0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;2-index-&quot;&gt;2. Использование .index() со строковым аргументом&lt;/h2&gt;
&lt;p&gt;Рассмотрим пример:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;test&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;foo1&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;foo&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;bar1&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;test&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;bar&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;baz1&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;baz&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;test&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;last&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.index( &amp;#39;selector&amp;#39; )&lt;/code&gt; запрашивает &lt;code&gt;.first()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $lis = $( &lt;span class=&quot;string&quot;&gt;'li'&lt;/span&gt; );
$lis.index( &lt;span class=&quot;string&quot;&gt;'li'&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; 0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;$li.index( &amp;#39;li&amp;#39; )&lt;/code&gt; ищет вхождения &lt;code&gt;&amp;#39;li&amp;#39;&lt;/code&gt; по &lt;em&gt;всему документу&lt;/em&gt; и выводит индекс элемента относительно всех &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; в 
документе:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;'#last'&lt;/span&gt;).index(&lt;span class=&quot;string&quot;&gt;'div'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;3-index-jquery-object-&quot;&gt;3. Использование .index() с jQuery-object в качестве аргумента&lt;/h2&gt;
&lt;p&gt;В этом случае ищется индекс элемента (первого, если передана коллекция) в скобках внутри коллекции, на которой вызыван 
&lt;code&gt;.index()&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;4-index-dom-object-&quot;&gt;4. Использование .index() с DOM-object в качестве аргумента&lt;/h2&gt;
&lt;p&gt;Работает аналогично случаю с передачей jQuery-объекта.        &lt;/p&gt;
&lt;h1 id=&quot;-jquery-&quot;&gt;Перебор jQuery объектов и примитивов&lt;/h1&gt;
&lt;p&gt;В jQuery есть метод &lt;code&gt;$.each&lt;/code&gt; для перебора массивов, псевдо-массивов и объектов (примитивов) и &lt;code&gt;.each&lt;/code&gt; для перебора 
jQuery-объектов (выборок). Они никак не пересекаются.&lt;/p&gt;
&lt;p&gt;Так же имеются шорткаты &lt;code&gt;$.map&lt;/code&gt; и &lt;code&gt;.map&lt;/code&gt;, которые решают определенные частные случаи переборов (подмножестово &lt;code&gt;each&lt;/code&gt;).&lt;/p&gt;
&lt;h2 id=&quot;-each-&quot;&gt;$.each()&lt;/h2&gt;
&lt;p&gt;Это метод-утилита для работы с примитивами: массивами, псевдомассивами и объектами (не с jQuery-объектами).&lt;/p&gt;
&lt;p&gt;Пример для массива:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;

    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; ];
    $.each( arr, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; index, value &lt;/span&gt;)&lt;/span&gt;{
        sum += value;
    });

    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( sum ); &lt;span class=&quot;comment&quot;&gt;// 15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Пример для объекта:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = {
        foo: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,
        bar: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;
    }

    $.each( obj, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; key, value &lt;/span&gt;) &lt;/span&gt;{
        sum += value;
    });

    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( sum ); &lt;span class=&quot;comment&quot;&gt;// 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-each-&quot;&gt;.each()&lt;/h2&gt;
&lt;p&gt;Итератор для работы с jQuery-коллекциями. Каждый элемент коллекции обрабатывается коллбэком, в который передается 
индекс элемента и его DOM-представление (не jQuery-объект). Это DOM-представление так же равно &lt;code&gt;this&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    $( &lt;span class=&quot;string&quot;&gt;&quot;li&quot;&lt;/span&gt; ).each( &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; index, listItem &lt;/span&gt;) &lt;/span&gt;{

        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; === listItem; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;

        &lt;span class=&quot;comment&quot;&gt;// For example only. You probably shouldn't call $.ajax() in a loop.&lt;/span&gt;
        $.ajax({
            success: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; data &lt;/span&gt;) &lt;/span&gt;{
               &lt;span class=&quot;comment&quot;&gt;// The context has changed.&lt;/span&gt;
               &lt;span class=&quot;comment&quot;&gt;// The &quot;this&quot; keyword no longer refers to listItem.&lt;/span&gt;
               &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; !== listItem; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;
            }
        });

    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Второй аргумент &lt;code&gt;listItem&lt;/code&gt; равен &lt;code&gt;this&lt;/code&gt; в контексте коллбэка. Однако бывает, что внутри коллбэка есть другие функции,
внутри которых будет свой &lt;code&gt;this&lt;/code&gt; и для читабельности кода в этом случае лучше использовать второй аргумент.        &lt;/p&gt;
&lt;p&gt;Часто методы jQuery не требуют запуска итератора. Например, так класс добавится ко всем &lt;code&gt;li&lt;/code&gt; без перебора:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    $( &lt;span class=&quot;string&quot;&gt;&quot;li&quot;&lt;/span&gt; ).addClass( &lt;span class=&quot;string&quot;&gt;&quot;newClass&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но некоторые требуют конктетного обращения к каждому элементу:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    $( &lt;span class=&quot;string&quot;&gt;&quot;input&quot;&lt;/span&gt; ).each( &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; i, el &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; elem = $( el );
        elem.val( elem.val() + &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt; );
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Часто геттеры возвращают значение первого элемента из колекции, а сеттеры, наоборот, обрабатывают всю коллекцию.
В такие сеттеры можно передать в качестве устанавливаемого значения коллбэк-функцию, которая пройдется по всем элементам
коллекции:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    $( &lt;span class=&quot;string&quot;&gt;&quot;input&quot;&lt;/span&gt; ).val( &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; i, el &lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; elem = $( el );
        elem.val( elem.val() + &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt; );
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-map-&quot;&gt;.map()&lt;/h2&gt;
&lt;p&gt;Пробегается по всем элементам коллекции и производит какие-то операции над каждым элементом. Возвращает 
jQuery-коллекцию.&lt;/p&gt;
&lt;p&gt;Если нужно вернуть простой массив, то заканчиваем цепочку методом &lt;code&gt;.get()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    $( &lt;span class=&quot;string&quot;&gt;&quot;li&quot;&lt;/span&gt; ).map( &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;index, element&lt;/span&gt;) &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.id;
    }).get();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Цепочку можно продолжать методами массива. Например сделать &lt;code&gt;.reverse()&lt;/code&gt; после &lt;code&gt;.get()&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-map-&quot;&gt;$.map()&lt;/h2&gt;
&lt;p&gt;Этот метод перебирает примитивы (массивы и объекты). В нем параметры &lt;code&gt;index&lt;/code&gt; и &lt;code&gt;value&lt;/code&gt; имеют другой порядок, чем в
&lt;code&gt;.each&lt;/code&gt; и прочих переборных методах для совместимости с ES5:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dimensions = { width: &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, height: &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, length: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; };
    dimensions = $.map( dimensions, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; value, index &lt;/span&gt;) &lt;/span&gt;{
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;Работа с элементами&lt;/h1&gt;
&lt;h2 id=&quot;get-set&quot;&gt;Get/Set&lt;/h2&gt;
&lt;p&gt;Большинство методов позволяют и установить и получить значение:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;.html()
.text()
.height()/.width()
.val()

.position() &lt;span class=&quot;comment&quot;&gt;// get only&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Установка нового значения затронет все элементы выборки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;'h1'&lt;/span&gt; ).text(&lt;span class=&quot;string&quot;&gt;'Hello'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// изменятся все h1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;-&quot;&gt;Перемещение, копирование и удаление элементов&lt;/h1&gt;
&lt;p&gt;Работая с элементами, у нас бывают 2 задачи:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Поместить выбранный элемент относительно другого элемента.&lt;/li&gt;
&lt;li&gt;Поместить какой-то элемент относительно выбранного элемента.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;$el.insertAfter( &amp;#39;#otherElement&amp;#39; )&lt;/code&gt; - поместить &lt;code&gt;$el&lt;/code&gt; после &lt;code&gt;#otherElement&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Аналогично будет: &lt;code&gt;$( &amp;#39;#otherElement&amp;#39; ).after($el)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Таким же образом работают:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.insertAfter()  | .after()
.insertBefore() | .before()
.appendTo()     | .append()
.prependTo()    | .preped()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;Какой метод вставки выбрать?&lt;/h2&gt;
&lt;p&gt;Если нужно сохранить ссылку на вставляемый элемент, то выбирает первую колонку: &lt;code&gt;.insertAfter&lt;/code&gt; и подобные. Эти методы 
вернут вставляемый элемент и можно будет с ним работать дальше в цепочке или сохранить в переменную:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var $test = $( &amp;#39;&amp;lt;i&amp;gt;test&amp;lt;/i&amp;gt;&amp;#39; )
                .insertAfter( &amp;#39;form&amp;#39; )
                .animate({ &amp;#39;marginLeft&amp;#39;: &amp;#39;10px&amp;#39; });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Эти методы &lt;em&gt;переносят&lt;/em&gt; элементы, не копируют. Если нам нужно именно скопировать элемент, то в начале нужно будет 
создать новый такой же, т. е. сделать его клон.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Клонирование&lt;/h2&gt;
&lt;p&gt;Элементы клонируются методом &lt;code&gt;.clone( [false|true] )&lt;/code&gt;. Этот методы вернет клонируемый элемент:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;#39;form&amp;#39; ).clone().appendTo( &amp;#39;body&amp;#39; ); // Копия без данных и событий. Например, обработчик submit не сработает.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Если нам нужно клонировать элемент со всеми закрепленными данными и обработчиками, то нужно передать флаг &lt;code&gt;true&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;#39;form&amp;#39; ).clone(true).appendTo( &amp;#39;body&amp;#39; ); // Все данные и обработчики сохранятся так же.
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;Удаление элементов&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.remove()&lt;/code&gt; — удалить выборку из документа. Метод вернет удаляемую выборку, все обработчики и данные будут так же 
удалены. Применяется, когда элементы нам больше не нужны. Или когда нужны, но без обработчиков и данных.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.detach()&lt;/code&gt; — удалить выборку из документа с &lt;em&gt;сохранением&lt;/em&gt; всех данных и обработчиков. Применяется, если нужно дальше
работать с удаляемыми элементами.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.detach()&lt;/code&gt; стоит использовать, когда нам нужно переработать структуру какого-то элемента (например, доабвить/удалить 
строки в таблицу). Сначала детачим элемента, делаем, что нужно, потом вставляем его обратно. Так мы не трогаем DOM, а
работаем с элементом в памяти. Это сокращает число запросов к дереву DOM и обеспечивает лучшую производительность.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.empty()&lt;/code&gt; — удалить содержимое элемента (его &lt;code&gt;innerHTML&lt;/code&gt;).    &lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Создание элементов&lt;/h2&gt;
&lt;p&gt;Создавать элементы можно с помощью функции &lt;code&gt;$()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;&amp;lt;p&amp;gt;This is a new paragraph&amp;lt;/p&amp;gt;&amp;quot; );
$( &amp;quot;&amp;lt;a/&amp;gt;&amp;quot;, {
    html: &amp;quot;This is a &amp;lt;strong&amp;gt;new&amp;lt;/strong&amp;gt; link&amp;quot;,
    &amp;quot;class&amp;quot;: &amp;quot;new&amp;quot;, // зарезервированное слово, пэотому в кавычках
    href: &amp;quot;foo.html&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Созданные элементы нужно еще добавить в DOM с помощью методов &lt;code&gt;.append()&lt;/code&gt;, &lt;code&gt;.insertAfter()&lt;/code&gt; и пр.&lt;/p&gt;
&lt;p&gt;Когда нужно добавить много элементов, не стоит это делать в цикле. Лучше сформировать содержимое и добавить его в DOM
один раз.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Работа с атрибутами&lt;/h2&gt;
&lt;p&gt;Метод &lt;code&gt;.attr()&lt;/code&gt; позволяет получить значение атрибута, установить его или записать сразу пачку атрибутов. При этом в 
качестве заначения можно передать функцию, которая получает индекс текущего элемента, текущее значение атрибута и 
возвращает новое значение:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;#39;a&amp;#39; ).attr( &amp;#39;href&amp;#39;, &amp;#39;newDestination.html&amp;#39; );
$( &amp;#39;a&amp;#39; ).attr({
    rel: &amp;#39;nofollow&amp;#39;,
    href: function( idx, href ) {
        return &amp;#39;/new/&amp;#39; + href
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;Материалы&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/using-jquery-core/manipulating-elements/&quot;&gt;http://learn.jquery.com/using-jquery-core/manipulating-elements/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.jquery.com/category/manipulation/&quot;&gt;http://api.jquery.com/category/manipulation/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.jquery.com/category/attributes/&quot;&gt;http://api.jquery.com/category/attributes/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;-&quot;&gt;Коллекции и селекторы&lt;/h1&gt;
&lt;h2 id=&quot;-&quot;&gt;Проверка на видимость элементов&lt;/h2&gt;
&lt;p&gt;Псевдо-селекторы jQuery &lt;code&gt;:hidden&lt;/code&gt; и &lt;code&gt;:visible&lt;/code&gt; смотрят не на css-свойства, а на физическое представление элемента, его 
ширину и высоту. Исключение - только &lt;code&gt;tr&lt;/code&gt;. У него берется &lt;code&gt;display&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Скорость&lt;/h2&gt;
&lt;p&gt;По возможности начинаем выборку с селектора по &lt;code&gt;id&lt;/code&gt;. Так будет быстрее всего.&lt;/p&gt;
&lt;p&gt;Если надо использовать выборку несколько раз — сохнаняем ее в переменную, имя начинаем с доллара:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var $divs = $(&amp;#39;div&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;$divs&lt;/code&gt; сохранит только те элементы, которые присутствую на странице при создании переменной.&lt;/p&gt;
&lt;p&gt;Если нужна динамическая выборка (живая коллекция), то можно использовать &lt;code&gt;elem.getElementsBy[Name|TagName|ClassName]&lt;/code&gt;.
В этом случае элементы не будут сохраняться, а будут выбираться каждый раз при вызове.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Проверка выборки на пустоту&lt;/h2&gt;
&lt;p&gt;Проверить, не пустая ли выборка:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Это не сработает.
// Всегда вернется объект, а он будет преобразован в true.
if ( $( &amp;quot;div.foo&amp;quot; ) ) {
    ...
}

// Вот так правильно. Тут 0 станет false:
if ( $( &amp;quot;div.foo&amp;quot; ).length ) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;Фильтры&lt;/h2&gt;
&lt;p&gt;Когда выборку нужно ограничить, можно к ней применить фильтры:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Усечение выборок: 
$( &amp;quot;div.foo&amp;quot; ).has( &amp;quot;p&amp;quot; );         // div.foo в которых есть &amp;lt;p&amp;gt;
$( &amp;quot;h1&amp;quot; ).not( &amp;quot;.bar&amp;quot; );           // h1 без класса .bar
$( &amp;quot;ul li&amp;quot; ).filter( &amp;quot;.current&amp;quot; ); // li с классом .current
$( &amp;quot;ul li&amp;quot; ).first();              // Первый li
$( &amp;quot;ul li&amp;quot; ).eq( 5 );              // Шестой li
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;filter-vs-find&quot;&gt;filter vs. find&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.filter&lt;/code&gt; - урезать коллекцию, &lt;code&gt;.find&lt;/code&gt; - найти что-то внутри элемента.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Выбор элементов формы по типу и состоянию&lt;/h2&gt;
&lt;p&gt;jQuery имеет собственный удобный API (псевдо-селекторы) для выборки элементов формы по типу и состоянию. Такого в CSS 
нет.&lt;/p&gt;
&lt;p&gt;Чтобы выборка по псевдо-селекторам работала быстро и использовала &lt;code&gt;querySelectorAll&lt;/code&gt;, а не механизмы поиска jQuery, 
нужно сначала найти элемента, а потом их отфильтровать по псевдо-селектору:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`$(&amp;#39;#myForm&amp;#39;).find(&amp;#39;input&amp;#39;).filter(&amp;#39;:checked&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;По состоянию:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;:checked&lt;/strong&gt; - все выбранные элементы формы. Учитываются checkbox, radio и &amp;lt;select&amp;gt;&amp;lt;option&amp;gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#myForm input:checked&quot;&lt;/span&gt; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;:disabled&lt;/strong&gt; - найти все элементы формы с атрибутом &lt;code&gt;disabled&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;#39; #myForm &amp;#39;).find(&amp;#39;input&amp;#39;).filter(&amp;#39;:disabled&amp;#39;); // Так будет работать быстрее всего
$(&amp;#39; #myForm input&amp;#39;).filter(&amp;#39;:disabled&amp;#39;); // Можно так
$(&amp;#39; #myForm input:disabled&amp;#39;); // Или так, тэг или выборка перед псевдо-селектором
$(&amp;#39; #myForm :disabled&amp;#39;); // А так лучше не надо
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;:enabled&lt;/strong&gt; - элементы без атрибута &lt;code&gt;disabled&lt;/code&gt;. Инверсия псевдо-селектора &lt;code&gt;:disabled&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;#39; #myForm input&amp;#39;).filter(&amp;#39;:enabled&amp;#39;); // Сначала выбираем, потом фильтруем
$(&amp;#39; #myForm input:enabled&amp;#39;); // Так тоже можно
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;:input&lt;/strong&gt; - выбрать все элементы, с типами input, textarea, select и button:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;:selected&lt;/strong&gt; — выбрать все выбранные option. Работает именно с тегами &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// BROKEN CODE: Так работать не будет
$( &amp;#39;#myForm&amp;#39; ).find( &amp;#39;select&amp;#39; ).filter( &amp;#39;:selected&amp;#39; );

// А так будет:
$( &amp;#39;#select1&amp;#39; ).find( &amp;#39;option&amp;#39; ).filter(&amp;#39;:selected&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;По типу:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;#39;#myForm&amp;#39; ).find( &amp;#39;input&amp;#39; ).filter( &amp;#39;:password&amp;#39; );
                                        :reset
                                        :radio
                                        :text
                                        :submit
                                        :checkbox
                                        :button
                                        :image
                                        :file
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;Работа с коллекциями&lt;/h2&gt;
&lt;p&gt;Методы, вызываемые из коллекций могут быть сеттерами и геттерами. Если передаем параметр — получается сеттер, если 
параметра нет, то геттер.&lt;/p&gt;
&lt;p&gt;Сеттеры затронут &lt;strong&gt;все&lt;/strong&gt; элементы из колекции:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;#39;h1&amp;#39; ).html( &amp;#39;Hello world&amp;#39; ); // Все h1 на странице изменят содержимое на &amp;#39;Hello world&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Геттеры вернут значение только первого элемента (за исключением &lt;code&gt;.text()&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;#39;h1&amp;#39; ).html(); // Содержимое первого h1 из коллекции
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;.text()&lt;/code&gt; вернет текстовый контент вообще всех заголовков:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;#39;h1&amp;#39; ).text(); // Текст вообще всех h1 на странице в одной строке
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;Цепочки вызовов&lt;/h2&gt;
&lt;p&gt;Цепочку вызовов можно продолжать при сеттерах (они вернут jQuery object), а геттеры вернут только то, что у них 
запросили, поэтому такая штука не сработает:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// BROKEN CODE: геттер вернет строку, цепочка вызовов закончится
$( &amp;quot;h1&amp;quot; ).html().addClass( &amp;quot;test&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Chaining хорошая штука, но нужно знать меру. Чтобы код получился более читабельным, лучше разбивать вызовы по строкам:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;#content&amp;quot; )
    .find( &amp;quot;h3&amp;quot; )
    .eq( 2 )
        .html( &amp;quot;new text for the third h3!&amp;quot; )
        .end() // Restores the selection to all h3s in #content
    .eq( 0 )
        .html( &amp;quot;new text for the first h3!&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Здесь &lt;code&gt;.end()&lt;/code&gt; вернет нас к первоначальной выборке (все h3).&lt;/p&gt;
&lt;h1 id=&quot;-&quot;&gt;Передвижение по выборке&lt;/h1&gt;
&lt;p&gt;Элементы в выборке, по которым мы можем передвигаться, могут быть 3 типов: parents, children, siblings (родители, 
дети и братья).&lt;/p&gt;
&lt;h2 id=&quot;html-&quot;&gt;HTML для демонстрации&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;grandparent&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;parent&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;
            &amp;lt;span class=&amp;quot;subchild&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;surrogateParent1&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;surrogateParent2&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-parents-&quot;&gt;Родительские элементы (parents)&lt;/h2&gt;
&lt;p&gt;Чтобы выбрать определенные родительские элементы доступны следующие методы: .parent(), .parents(), .parentsUntil() 
and .closest():&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Вернет [ div.child ]
$( &amp;quot;span.subchild&amp;quot; ).parent();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Выбрать родительские элементы, соответствующие селектору:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;span.subchild&amp;quot; ).parents( &amp;quot;div.parent&amp;quot; ); // [ div.parent ]
$( &amp;quot;span.subchild&amp;quot; ).parents(); // [ div.child, div.parent, div.grandparent ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Выбрать родителей до селектора, &lt;em&gt;не включая его&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;span.subchild&amp;quot; ).parentsUntil( &amp;quot;div.grandparent&amp;quot; ); // [ div.child, div.parent ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Выбрать один ближайший родительский элемент. В том числе вернется &lt;em&gt;сам элемент&lt;/em&gt;, если он соответствует селектору:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;span.subchild&amp;quot; ).closest( &amp;quot;div&amp;quot; ); // [ div.child ]
$( &amp;quot;div.child&amp;quot; ).closest( &amp;quot;div&amp;quot; ); // [ div.child ], вернется сам элемент, т. к. он включен в поиск
                                   // и соответствует селектору
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-children-&quot;&gt;Дочерние элементы (children)&lt;/h2&gt;
&lt;p&gt;Для доступа к дочерним элементам используются методы &lt;code&gt;.children()&lt;/code&gt; и &lt;code&gt;.find()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.children()&lt;/code&gt; — работает только с непосредственными детьми (div &amp;gt; p).
&lt;code&gt;.find()&lt;/code&gt; — углубляется рекурсивно внутрь элемента&lt;/p&gt;
&lt;p&gt;Выбор непосредственных детей:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;div.grandparent&amp;quot; ).children( &amp;quot;div&amp;quot; ); // [ div.parent, div.surrogateParent1, div.surrogateParent2 ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Все элементы в выборке, которые соответствуют селектору:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;div.grandparent&amp;quot; ).find( &amp;quot;div&amp;quot; ); // [ div.parent, div.child, div.surrogateParent1, div.surrogateParent2 ]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-siblings-&quot;&gt;Одноуровневые элементы (братья, siblings)&lt;/h2&gt;
&lt;p&gt;Для поиска одноуровневых элементов используются метды &lt;code&gt;.prev()&lt;/code&gt;, &lt;code&gt;.next()&lt;/code&gt;, &lt;code&gt;.siblings()&lt;/code&gt;, &lt;code&gt;.prevAll()&lt;/code&gt;, &lt;code&gt;.prevUntill()&lt;/code&gt;,
&lt;code&gt;.nextAll()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Следующий элемент такого же уровня:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;div.parent&amp;quot; ).next(); // [ div.surrogateParent1 ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Предыдущий селектор такого же уровня:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;div.parent&amp;quot; ).prev(); // [] as No sibling exists before div.parent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Все последующие элементы такого же уровня:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;div.parent&amp;quot; ).nextAll(); // [ div.surrogateParent1, div.surrogateParent2 ]
$( &amp;quot;div.parent&amp;quot; ).nextAll().first(); // [ div.surrogateParent1 ]
$( &amp;quot;div.parent&amp;quot; ).nextAll().last(); // [ div.surrogateParent2 ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Все предыдущие элементы такого же уровня:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;div.surrogateParent2&amp;quot; ).prevAll(); // [ div.surrogateParent1, div.parent ]
$( &amp;quot;div.surrogateParent2&amp;quot; ).prevAll().first(); // [ div.surrogateParent1 ]
$( &amp;quot;div.surrogateParent2&amp;quot; ).prevAll().last(); // [ div.parent ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Все элементы такого же уровня во всех направлениях (и до и после):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;div.parent&amp;quot; ).siblings(); // [ div.surrogateParent1, div.surrogateParent2 ]
$( &amp;quot;div.surrogateParent1&amp;quot; ).siblings(); // [ div.parent, div.surrogateParent2 ]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;Сложные переходы&lt;/h2&gt;
&lt;p&gt;Не стоит строить длинные цепочки переходов. Нужно иметь ввиду, что при поддержке сайта DOM может изменяться со 
временем и длинные переходы могут перестать работать. Пара-тройка элементов — ок, а если нужно найти дочерние 
элементы в соседнем блоке, тот тут лучше отдельно найти элементы. Так гибче.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;Материалы&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/using-jquery-core/traversing/&quot;&gt;Traversing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.jquery.com/category/traversing/tree-traversal/&quot;&gt;Category: Tree Traversal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;-&quot;&gt;Полезные функции из $&lt;/h1&gt;
&lt;p&gt;В объекте &lt;code&gt;$&lt;/code&gt; содержится масса полезных фнукций для рутинных задач.&lt;/p&gt;
&lt;p&gt;Вот несколько примеров.&lt;/p&gt;
&lt;h2 id=&quot;-trim-&quot;&gt;$.trim()&lt;/h2&gt;
&lt;p&gt;Убирает лишние пробелы в начале и в конце:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.trim( &amp;quot;    lots of extra whitespace    &amp;quot; ); // &amp;quot;lots of extra whitespace&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-each&quot;&gt;$.each&lt;/h2&gt;
&lt;p&gt;Перебор массивов и объектов:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.each([ &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; ], function( idx, val ) {
    console.log( &amp;quot;element &amp;quot; + idx + &amp;quot; is &amp;quot; + val );
});

$.each({ foo: &amp;quot;bar&amp;quot;, baz: &amp;quot;bim&amp;quot; }, function( k, v ) {
    console.log( k + &amp;quot; : &amp;quot; + v );
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;$.each != .each&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$.each()&lt;/code&gt; работает с примитивами: массивы и объекты, &lt;code&gt;.each()&lt;/code&gt; работает только с выборкой jQuery.&lt;/p&gt;
&lt;p&gt;Для массивов есть нативный &lt;code&gt;Array.prototype.forEach&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-inarray-&quot;&gt;$.inArray()&lt;/h2&gt;
&lt;p&gt;Вернет индекс значения или -1, если значение не нашлось:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var myArray = [ 1, 2, 3, 5 ];

if ( $.inArray( 4, myArray ) !== -1 ) {
    console.log( &amp;quot;found it!&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Начиная с IE9 есть нативный &lt;code&gt;Array.prototype.indexOf&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-extend-&quot;&gt;$.extend()&lt;/h2&gt;
&lt;p&gt;Расширяет (изменяет и дополняет) свойства первого объекта свойствами других объектов:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var firstObject = { foo: &amp;quot;bar&amp;quot;, a: &amp;quot;b&amp;quot; };
var secondObject = { foo: &amp;quot;baz&amp;quot; };

var newObject = $.extend( firstObject, secondObject );

console.log( firstObject.foo ); // &amp;quot;baz&amp;quot;, изменилось
console.log( newObject.foo ); // &amp;quot;baz&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Если не нужно изменять первый объект, то первым аргументом нужно передать пустой объект:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var firstObject = { foo: &amp;quot;bar&amp;quot;, a: &amp;quot;b&amp;quot; };
var secondObject = { foo: &amp;quot;baz&amp;quot; };

var newObject = $.extend( {}, firstObject, secondObject );

console.log( firstObject.foo ); // &amp;quot;bar&amp;quot;
console.log( newObject.foo ); // &amp;quot;baz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-proxy-&quot;&gt;$.proxy()&lt;/h2&gt;
&lt;p&gt;Назначает контекст выполнения для функции. Вторым аргументом передается объект:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var myFunction = function() {
    console.log( this );
};
var myObject = {
    foo: &amp;quot;bar&amp;quot;
};

myFunction(); // window

var myProxyFunction = $.proxy( myFunction, myObject );

myProxyFunction(); // myObject
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Если нужно сохранить контекст для метода из объекта (оставить в методе &lt;code&gt;this&lt;/code&gt;, равный этому объекту), то в &lt;code&gt;$.proxy&lt;/code&gt; 
нужно передать объект и имя метода. В этом случае вернется функция, за которой закрепится контекст:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var myObject = {
    myFn: function() {
        console.log( this );
    }
};

$( &amp;quot;#foo&amp;quot; ).click( myObject.myFn ); // HTMLElement #foo
$( &amp;quot;#foo&amp;quot; ).click( $.proxy( myObject, &amp;quot;myFn&amp;quot; ) ); // myObject
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Начиная с IE9 есть нативный &lt;code&gt;.bind(this)&lt;/code&gt; для функций. Последний пример можно написать так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;#foo&amp;quot; ).click( myObject.myFn.bind(myObject) );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Или так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;#foo&amp;quot; ).click( function() { myObject.myFn.call(myObject) } );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Или так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;quot;#foo&amp;quot; ).click( function() { myObject.myFn() } );
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;Проверка типов&lt;/h2&gt;
&lt;p&gt;Есть методы для проверки типа значения:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.isArray([]); // true. Есть нативный аналог: Array.isArray([]), IE9+
$.isFunction(function() {}); // true
$.isNumeric(3.14); // true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Помимо этого имеется метод &lt;code&gt;$.type()&lt;/code&gt;, который проверяет тип значения по его прототипу:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.type( true ); // &amp;quot;boolean&amp;quot;
$.type( 3 ); // &amp;quot;number&amp;quot;
$.type( &amp;quot;test&amp;quot; ); // &amp;quot;string&amp;quot;
$.type( function() {} ); // &amp;quot;function&amp;quot;

$.type( new Boolean() ); // &amp;quot;boolean&amp;quot;
$.type( new Number(3) ); // &amp;quot;number&amp;quot;
$.type( new String(&amp;#39;test&amp;#39;) ); // &amp;quot;string&amp;quot;
$.type( new Function() ); // &amp;quot;function&amp;quot;

$.type( [] ); // &amp;quot;array&amp;quot;
$.type( null ); // &amp;quot;null&amp;quot;
$.type( /test/ ); // &amp;quot;regexp&amp;quot;
$.type( new Date() ); // &amp;quot;date&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;Материалы&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learn.jquery.com/using-jquery-core/utility-methods/&quot;&gt;Utility Methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.jquery.com/category/utilities/&quot;&gt;Category: Utilities&lt;/a&gt;            &lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
  </channel>
</rss>