<!DOCTYPE html>
<div class="top-nav content-wrap"><a href="/learn/">« Назад на главную</a></div>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>jQuery Widget Factory - Занятия по фронтэнду
    </title>
    <link rel="alternate" href="http://amiskov.github.io/learn//feed.xml" type="application/rss+xml" title="тезисы, примеры и домашние задания">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/learn/css/main.css">
    <script src="/learn/js/jquery-2.1.4.min.js"></script>
    <script src="/learn/js/script.js"></script>
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>jQuery Widget Factory</h1>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>Если нам нужен компонент, который будет менять состояния, взаимодействовать с другими компонентами, 
включаться/отключаться и т. д., то плагины могут быть не слишком удобны в использовании. Для таких случаев придумали
jQuery Widget Factory.
<span class="more"></span></p>
<p>Плагины нужны, чтобы расширить существующий функционал фреймворка. Обычно они запускаются на коллекции, что-то с ней 
делают и возвращают эту же коллекцию, обеспечивая цепочность&nbsp;вызовов.</p>
<p>Обычно jQuery-плагины применяются без настроек и результат их выполнения всегда&nbsp;одинаков.</p>
<p><code>$(&#39;div&#39;).text(&#39;Hello&#39;)</code> — для такого рода операций плагин — самое то. <code>.text()</code> добавляет текст в элемент и на этом 
его работа&nbsp;заканчивается.</p>
<p>Если нам нужно произвести инициализацию компонента, следить за его <a href="http://en.wikipedia.org/wiki/State_%28computer_science%29">состоянием</a> и изменять 
его в зависимости от разлиынх условий, то тут потребуется писать код, типичный для многих таких 
виджетов. Разные авторы могут по-разному подходить к реализации своих <span class="caps">API</span>. Это влечет снижение консистентности кода и
 лишние затраты&nbsp;времени.</p>
<p>Для того, чтобы создавать более ООП-ориентированные сущности и в то же время быть в среде jQuery придумали <a href="http://jqueryui.com/widget/">jQuery 
Widget Factofy</a>, которая является частью jQuery <span class="caps">UI</span> и может быть использована отдельно 
(7Кб в сжатом&nbsp;виде). </p>
<h2 id="widget-factory">Widget&nbsp;factory</h2>
<p>Widget factory предоставляет ряд соглашений и готового функционала для того, чтобы написание виджетов было однотипным и 
получаемый <span class="caps">API</span> работал одним образом. Сохраняем время на рутинных операциях (инициализация, дестрой, триггеринг 
событий) используем соглашения для приватных и публичных метоодов, получаем более более качественный результат и 
экономим время. Научились использовать один виджет из jQuery UI — умеем пользоваться&nbsp;всеми.</p>
<p>В Magento 2.0 Widget Factory <a href="http://devdocs.magento.com/guides/v2.0/coding-standards/code-standard-jquery-widgets.html">является стандартом</a> для создания компонентов&nbsp;интерфейса.</p>
<h2 id="-">Консистентность&nbsp;кода</h2>
<p>jQuery Widget Factory прежде всего решает задачу по организации кода. Следование соглашениям в команде позволяет не 
тратить время, раздумывая над <span class="caps">API</span> виджета при разработке и над вызовом методов, установкой свойств при&nbsp;использовании.</p>
<h2 id="-">Преимущества</h2>
<ul>
<li>Наследование и&nbsp;полиморфизм</li>
<li>Конструктор/Деструктор <code>_create</code>/<code>_destroy</code></li>
<li>Псевдоселектор <code>$(&#39;:ns-plugin&#39;)</code></li>
<li>Приватные и публичные&nbsp;методы</li>
<li>Механизм колбэков (<code>_trigger</code>)</li>
</ul>
<h2 id="-">Соглашения</h2>
<ul>
<li>Создание и удаление&nbsp;виджетов;</li>
<li>Установка и получение опций (геттеры и&nbsp;сеттеры);</li>
<li>Вызов&nbsp;методов;</li>
<li>Прослушивание и вызов событий, которые инициирует&nbsp;виджет.</li>
</ul>
<p>Состояние объекта — набор данных о нем в текущий момент времени: значение (проценты в прогрессбаре), открыт он или 
закрыт, какой пункт выделеин и т.&nbsp;д.</p>
<p>Виджеты имеют жизненный цикл — от инициализации до&nbsp;дестроя.</p>
<p>Инициализация&nbsp;прогрессбара:</p>
<pre><code class="lang-js"><span class="comment">// Без параметров, с дефолтными настройками</span>
$( <span class="string">"#elem"</span> ).progressbar();
<span class="comment">// Со своими параметрами</span>
$( <span class="string">"#elem"</span> ).progressbar({ value: <span class="number">20</span> });
</code></pre>
<p>Параметры — часть состояния виджета. Их мы можем менять в течение жизненного цикла через метод <a href="http://api.jqueryui.com/jQuery.widget/#method-option"><code>option</code></a>.</p>
<h2 id="-">Параметры при&nbsp;инициализации</h2>
<p>Для плагина хорошая практика — набор дефолтных опций и предоставление внешнего интерфейса к&nbsp;ним:</p>
<pre><code class="lang-js">$.fn.plugin = <span class="function"><span class="keyword">function</span>(<span class="params"> options </span>) </span>{
    options = $.extend( {}, $.fn.plugin.defaults, options );
    <span class="comment">// Plugin logic goes here.</span>
};

$.fn.plugin.defaults = {
    param1: <span class="string">"foo"</span>,
    param2: <span class="string">"bar"</span>,
    param3: <span class="string">"baz"</span>
};
</code></pre>
<p>Здесь мы вручную выносим дефолтные настройки в метод функции, пользуясь тем, что функция — это&nbsp;объект.</p>
<p><code>$.widget</code> позволяет это делать даже&nbsp;проще:</p>
<pre><code class="lang-js">$.widget( <span class="string">"ns.plugin"</span>, {

    <span class="comment">// Default options.</span>
    options: {
        param1: <span class="string">"foo"</span>,
        param2: <span class="string">"bar"</span>,
        param3: <span class="string">"baz"</span>
    },

    <span class="comment">// Этот методы вызовется при первом обращении к виджету: $('div').widgetName();</span>
    _create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="comment">// Options are already merged and stored in this.options</span>
        <span class="comment">// Plugin logic goes here.</span>
    }

});
</code></pre>
<p>Мы из коробки имеем смерженные дефолтные и юзерские параметры и доступ к ним&nbsp;извне.</p>
<h1 id="-">Методы</h1>
<p>После инициализации виджета мы можем следить за его состоянием, менять его и выполнять с помощью виджета какие-то 
действия. Выполнить действие — запустить метод. Метод запускается&nbsp;так:</p>
<pre><code class="lang-js">$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"value"</span> ); <span class="comment">// Геттер</span>
$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"value"</span>, <span class="number">40</span> ); <span class="comment">// Сеттер (передали параметр)</span>

<span class="comment">// При таком вызове метода (а-ля плагин) виджет возвращает jQuery object, так что можно</span>
<span class="comment">// продолжать цепочку вызовов:</span>
$( <span class="string">"#elem"</span> )
    .progressbar( <span class="string">"value"</span>, <span class="number">90</span> )
    .addClass( <span class="string">"almost-done"</span> );
</code></pre>
<h2 id="-">Общие&nbsp;методы</h2>
<p>Некоторые методы идут из&nbsp;коробки.</p>
<p><strong>option</strong> позволяет установить параметр после инициализации&nbsp;виджета:</p>
<pre><code class="lang-js"><span class="comment">// Получить значение (геттер)</span>
$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"option"</span>, <span class="string">"value"</span> );

<span class="comment">// Установить значение (сеттер)</span>
$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"option"</span>, <span class="string">"value"</span>, <span class="number">30</span> );

<span class="comment">// Перезаписать сразу несколько параметров</span>
$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"option"</span>, {
    value: <span class="number">100</span>,
    disabled: <span class="literal">true</span>
});
</code></pre>
<p>Получение и установка значений следует синтаксису jQuery core. Например, <code>$(&#39;div&#39;).css()</code>. Отличие в том, что в 
виджет передается еще одни параметр — имя&nbsp;метода.</p>
<p><strong>disable</strong> — метод для отключения виджета. Например, прогрессбар становится серым и перестает&nbsp;изменяться.</p>
<pre><code class="lang-js">$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"disable"</span> );
$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"option"</span>, <span class="string">"disabled"</span>, <span class="literal">true</span> ); <span class="comment">// Эквивалентный синтаксис</span>
</code></pre>
<p><strong>enable</strong> — метод включения виджета (выключение отключения&nbsp;&uarr;):</p>
<pre><code class="lang-js">$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"enable"</span> );
$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"option"</span>, <span class="string">"disabled"</span>, <span class="literal">false</span> ); <span class="comment">// Эквивалентный синтаксис</span>
</code></pre>
<p><strong>destroy</strong> — грохнуть виджет, закончить его жизненный&nbsp;цикл:</p>
<pre><code class="lang-js">$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"destroy"</span> );
</code></pre>
<p>После удаления виджета работать с ним нельзя. Надо работать — инициализируем заново. При вызове <code>.remove()</code> у 
элемента виджета, при изменении <code>.html()</code> или вызове <code>.empty()</code> у родителей <code>destroy</code> вызывается&nbsp;автоматически.</p>
<p><strong>widget</strong> вернет сгенерированную виджетом разметку. Если таковой нет, то вернется исходный&nbsp;элемент:</p>
<pre><code class="lang-js">$( <span class="string">"#elem"</span> ).progressbar( <span class="string">"widget"</span> );
</code></pre>
<h1 id="-">События</h1>
<p>Видеты могут триггерить события при изменении состояния. Обычно к именам событияй виджета добавляется префикс — 
название&nbsp;виджета:</p>
<pre><code class="lang-js">$( <span class="string">"#elem"</span> ).on( <span class="string">"progressbarchange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    alert( <span class="string">"The value has changed!"</span> );
});
</code></pre>
<p>Каждому событию соответствует коллбэк, который мы можем&nbsp;переопределить:</p>
<pre><code class="lang-js">$( <span class="string">"#elem"</span> ).progressbar({
    change: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        alert( <span class="string">"The value has changed!"</span> );
    }
});
</code></pre>
<h2 id="-">Общие&nbsp;события</h2>
<p>У всех виджетов уже есть событие <code>create</code>, которое сработает при создании&nbsp;виджета.</p>
<h1 id="-">Написание&nbsp;виджета</h1>
<p>Рассмотрим написание виджета на примере <a href="http://jqueryui.com/progressbar/">прогрессбара</a>.</p>
<p>В метод <code>$.widget</code> передается 2 параметра: имя плагина и объект с его функционалом. Widget factory создаст 
конструктор и будет использовать переданный объект как прототип для него. Весь дефолтный функционал будет браться из 
<code>jQuery.Widget.prototype</code>. У плагина контекст (<code>this</code>) — это <span class="caps">DOM</span>-элемент, у виджета контекст — единичный экземпляр&nbsp;объекта:</p>
<pre><code class="lang-js">$.widget( <span class="string">"nmk.progressbar"</span>, { <span class="comment">// nmk — namespace, progressbar - widget name</span>

    _create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">var</span> progress = <span class="keyword">this</span>.options.value + <span class="string">"%"</span>;
        <span class="keyword">this</span>.element.addClass( <span class="string">"progressbar"</span> ).text( progress );
    }

});
</code></pre>
<p>При создании, экземпляр виджета сохраняется в <code>.data</code> <span class="caps">DOM</span>-объекта:</p>
<pre><code class="lang-js"><span class="keyword">var</span> bar = $( <span class="string">"&lt;div /&gt;"</span>)
    .appendTo( <span class="string">"body"</span> )
    .progressbar()
    .data( <span class="string">"nmk-progressbar"</span> );

<span class="comment">// Call a method directly on the plugin instance.</span>
bar.option( <span class="string">"value"</span>, <span class="number">50</span> );

<span class="comment">// Access properties on the plugin instance.</span>
alert( bar.options.value );
</code></pre>
<p>Widget Factory позволяет работать с прототипом всех созданных сущностей. Добавляя новые методы, они становятся 
доступны всем&nbsp;эзкемплярам:</p>
<pre><code class="lang-js">$.nmk.progressbar.prototype.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">this</span>._setOption( <span class="string">"value"</span>, <span class="number">0</span> );
};
</code></pre>
<h2 id="-">Соглашения</h2>
<p>Пространство имен: имя плагина начинается с неймспейса, далее следует точка и после точки идет имя плагина:
<code>nmk.progressbar</code>. Неймспейс <code>ui</code> занят компонентами библиотеки jQuery <span class="caps">UI</span>. Нам следует использовать свое собственное 
пространство&nbsp;имен.</p>
<p><code>this.element</code> — объект jQuery (единичный). Если Widget Factory, вызывается на коллекции элементов, то для каждого 
элемента создается <em>свой собственный</em> экземляр. Эти экземпляры унаследуют методы и свойства от одного&nbsp;прототипа.</p>
<p><code>this.options</code> — объект с опциями, которые переданы при&nbsp;инициализации.</p>
<p>Значения по умолчанию (опции и коллбэки) мы можем обозначить как объект <code>options</code>:</p>
<pre><code class="lang-js">$.widget( <span class="string">"nmk.progressbar"</span>, {

    <span class="comment">// Default options.</span>
    options: {
        value: <span class="number">0</span>,

        callback: <span class="literal">null</span> <span class="comment">// Callbacks are also here</span>
    },

    _create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">var</span> progress = <span class="keyword">this</span>.options.value + <span class="string">"%"</span>;
        <span class="keyword">this</span>.element.addClass( <span class="string">"progressbar"</span> ).text( progress );
    }

});
</code></pre>
<p>Widget factory предоставляет удобные способ управления состоянием плагина и соглашение по выполнению частых задач, 
типа работы с приватными и внешними&nbsp;методами.</p>
<h2 id="-">Добавление&nbsp;методов</h2>
<p>Мы можем добавить методы в наш объект, в том числе приватные, начав их имена с подчеркивания. Снаружи они будут&nbsp;недоступны:</p>
<pre><code class="lang-js">$.widget( <span class="string">"nmk.progressbar"</span>, {
    options: {
        value: <span class="number">0</span>
    },

    _create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">var</span> progress = <span class="keyword">this</span>.options.value + <span class="string">"%"</span>;
        <span class="keyword">this</span>.element.addClass(<span class="string">"progressbar"</span>).text( progress );
    },

    <span class="comment">// Create a public method.</span>
    value: <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>) </span>{

        <span class="comment">// No value passed, act as a getter.</span>
        <span class="keyword">if</span> ( value === <span class="literal">undefined</span> ) {

            <span class="keyword">return</span> <span class="keyword">this</span>.options.value;

        <span class="comment">// Value passed, act as a setter.</span>
        } <span class="keyword">else</span> {

            <span class="keyword">this</span>.options.value = <span class="keyword">this</span>._constrain( value );
            <span class="keyword">var</span> progress = <span class="keyword">this</span>.options.value + <span class="string">"%"</span>;
            <span class="keyword">this</span>.element.text( progress );

        }

    },

    <span class="comment">// Create a private method.</span>
    _constrain: <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>) </span>{

        <span class="keyword">if</span> ( value &gt; <span class="number">100</span> ) {
            value = <span class="number">100</span>;
        }

        <span class="keyword">if</span> ( value &lt; <span class="number">0</span> ) {
            value = <span class="number">0</span>;
        }

        <span class="keyword">return</span> value;
    }

});
</code></pre>
<p>Для вызова методов нужно передать параметр в виджет. Если нужно установить значение, то передаем его&nbsp;следом:</p>
<pre><code class="lang-js"><span class="keyword">var</span> bar = $( <span class="string">"&lt;div /&gt;"</span> ).appendTo( <span class="string">"body"</span>).progressbar({ value: <span class="number">20</span> });

<span class="comment">// Get the current value.</span>
alert( bar.progressbar( <span class="string">"value"</span> ) );

<span class="comment">// Update the value.</span>
bar.progressbar( <span class="string">"value"</span>, <span class="number">50</span> );

<span class="comment">// Get the current value again.</span>
alert( bar.progressbar( <span class="string">"value"</span> ) );
</code></pre>
<p>Это не самый удобный способ работы. Так сделано для того, чтобы по-минимуму воздействовать своими методами на объект 
<code>$</code>.</p>
<h2 id="-">Работа с&nbsp;опциями</h2>
<p>Widget Factory предоставляет возможность работы с опциями. С помощью метода <code>option()</code> можно получать и устанавливать
опции после инициализации используя его как геттер и сеттер. В него можно передавать единичные мараметры или срзау&nbsp;объект.</p>
<p>При установке опций вызывается метод <code>_setOption</code> для каждого передаваемого свойства. Этот метод мы можем указать 
руками, чтобы контролировать установку&nbsp;опций.</p>
<p>Если нам нужно что-то сделать со всей пачкой передаваемых опций, в нашем распоряжении имеетс метод <code>_setOptions</code>.</p>
<pre><code class="lang-js">$.widget( <span class="string">"custom.progressbar"</span>, {
    options: {
        value: <span class="number">0</span>
    },
    _create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">this</span>.options.value = <span class="keyword">this</span>._constrain(<span class="keyword">this</span>.options.value);
        <span class="keyword">this</span>.element.addClass( <span class="string">"progressbar"</span> );
        <span class="keyword">this</span>.refresh();
    },
    _setOption: <span class="function"><span class="keyword">function</span>(<span class="params"> key, value </span>) </span>{
        <span class="keyword">if</span> ( key === <span class="string">"value"</span> ) {
            value = <span class="keyword">this</span>._constrain( value );
        }
        <span class="keyword">this</span>._super( key, value );
    },
    _setOptions: <span class="function"><span class="keyword">function</span>(<span class="params"> options </span>) </span>{
        <span class="keyword">this</span>._super( options );
        <span class="keyword">this</span>.refresh();
    },
    refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">var</span> progress = <span class="keyword">this</span>.options.value + <span class="string">"%"</span>;
        <span class="keyword">this</span>.element.text( progress );
    },
    _constrain: <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>) </span>{
        <span class="keyword">if</span> ( value &gt; <span class="number">100</span> ) {
            value = <span class="number">100</span>;
        }
        <span class="keyword">if</span> ( value &lt; <span class="number">0</span> ) {
            value = <span class="number">0</span>;
        }
        <span class="keyword">return</span> value;
    }
});
</code></pre>
<h2 id="callbacks">Callbacks</h2>
<p>Для того, чтобы реагировать на изменение состояния нашего виджета предусмотрен механизм работы с колбэк-функциями. В 
прмере ниже с помощью метода <code>_trigger</code> вызывается метод <code>complete</code>, который сработает, когда значение прогрессбара 
достигнет&nbsp;100%.</p>
<pre><code class="lang-js">$.widget( <span class="string">"custom.progressbar"</span>, {
    options: {
        value: <span class="number">0</span>
    },
    _create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">this</span>.options.value = <span class="keyword">this</span>._constrain(<span class="keyword">this</span>.options.value);
        <span class="keyword">this</span>.element.addClass( <span class="string">"progressbar"</span> );
        <span class="keyword">this</span>.refresh();
    },
    _setOption: <span class="function"><span class="keyword">function</span>(<span class="params"> key, value </span>) </span>{
        <span class="keyword">if</span> ( key === <span class="string">"value"</span> ) {
            value = <span class="keyword">this</span>._constrain( value );
        }
        <span class="keyword">this</span>._super( key, value );
    },
    _setOptions: <span class="function"><span class="keyword">function</span>(<span class="params"> options </span>) </span>{
        <span class="keyword">this</span>._super( options );
        <span class="keyword">this</span>.refresh();
    },
    refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">var</span> progress = <span class="keyword">this</span>.options.value + <span class="string">"%"</span>;
        <span class="keyword">this</span>.element.text( progress );
        <span class="keyword">if</span> ( <span class="keyword">this</span>.options.value == <span class="number">100</span> ) {
            <span class="keyword">this</span>._trigger( <span class="string">"complete"</span>, <span class="literal">null</span>, { value: <span class="number">100</span> } ); <span class="comment">// вызов колбэка и триггеринг события</span>
        }
    },
    _constrain: <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>) </span>{
        <span class="keyword">if</span> ( value &gt; <span class="number">100</span> ) {
            value = <span class="number">100</span>;
        }
        <span class="keyword">if</span> ( value &lt; <span class="number">0</span> ) {
            value = <span class="number">0</span>;
        }
        <span class="keyword">return</span> value;
    }
});
</code></pre>
<p>Метод <code>_trigger</code> принимает 3 параметра: имя колбэка, объект события jQuery и объект данных. Колбэк-функция — это один
из параметров. Ее можно получать и вызывать как обычные опции. На ряду с колбэк-функций триггериться и событие. Имя 
события получается из объединения имени виджета и колбэк-функции: <code>progressbarcomplete</code>.</p>
<pre><code class="lang-js"><span class="keyword">var</span> bar = $( <span class="string">"&lt;div&gt;&lt;/div&gt;"</span> )
    .appendTo( <span class="string">"body"</span> )
    .progressbar({
        complete: <span class="function"><span class="keyword">function</span>(<span class="params"> event, data </span>) </span>{
            alert( <span class="string">"Callbacks are great!"</span> );
        }
    })
    .bind( <span class="string">"progressbarcomplete"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event, data </span>) </span>{
        alert( <span class="string">"Events bubble and support many handlers for extreme flexibility."</span> );
        alert( <span class="string">"The progress bar value is "</span> + data.value );
    });

bar.progressbar( <span class="string">"option"</span>, <span class="string">"value"</span>, <span class="number">100</span> );
</code></pre>
<h1 id="-widget-factory">Как работает Widget&nbsp;Factory</h1>
<p>Вызов <code>$.widget(&#39;namespace.widgetname&#39;, widgetObject)</code> создает конструктор и устанавливает его прототипом 
передаваемый <code>widgetObject</code>. Таким образом все создаваемые сущности унаследуют от <code>widgetObject</code>.</p>
<p>Сам объект унаследует дефолтный функционал от <code>jQuery.Widget.prototype</code> (Widget с большой&nbsp;буквы).</p>
<p>Для примера можно рассмотреть <a href="http://jqueryui.com/resources/demos/progressbar/default.html">http://jqueryui.com/resources/demos/progressbar/default.html</a></p>
<p>Запустив в консоли <code>$.ui.progressbar.prototype</code> можно увидеть объект, от которого виджет наследует методы и свойства
присущие ему из&nbsp;коробки.</p>
<p>При создании виджета ссылка на его объект содержится в <code>jQuery.data</code> <span class="caps">DOM</span>-элемента. На той же странице можно 
посмотреть <code>$( &quot;#progressbar&quot; ).data(&#39;uiProgressbar&#39;)</code> и его <code>__proto__</code>. А раз так, то мы можем записать ее в 
переменную и обращаться к методам и свойсвтам через точку, а не передавая в скобках&nbsp;названия:</p>
<pre><code class="lang-js"><span class="keyword">var</span> bar = $( <span class="string">"&lt;div&gt;&lt;/div&gt;"</span> )
    .appendTo( <span class="string">"body"</span> )
    .progressbar()                 <span class="comment">// Инициализировали виджет</span>
    .data( <span class="string">"custom-progressbar"</span> ); <span class="comment">// Достали и сохранили в bar ссылку на объект виджета</span>

<span class="comment">// Call a method directly on the plugin instance.</span>
bar.option( <span class="string">"value"</span>, <span class="number">50</span> );

<span class="comment">// Access properties on the plugin instance.</span>
alert( bar.options.value );
</code></pre>
<p>Так же можно вызывать конструктор виджета&nbsp;напрямую:</p>
<pre><code class="lang-js"><span class="keyword">var</span> bar = $.custom.progressbar({},       <span class="comment">// возможные опции</span>
    $( <span class="string">"&lt;div&gt;&lt;/div&gt;"</span> ).appendTo( <span class="string">"body"</span>) <span class="comment">// элемент виджета</span>
);

<span class="comment">// Same result as before.</span>
alert( bar.options.value );
</code></pre>
<h2 id="-">Добавление/изменение методов в прототипе&nbsp;виджета</h2>
<p>Поскольку в виджете мы работаем с конструктором и прототипом (в плагине мы не имеем таких возможностей), то мы можем 
легко расширять его функционал: добавлять новые методы или изменять&nbsp;существующие:</p>
<pre><code class="lang-js"><span class="comment">// Добавим метод для сбрасывания значения прогрессбара</span>
$.custom.progressbar.prototype.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">this</span>._setOption( <span class="string">"value"</span>, <span class="number">0</span> );
};
</code></pre>
<h1 id="-">Дестрой</h1>
<p>Для того, чтобы удалить виджет и почистить за собой существует метод <code>_destroy</code>. Из коробки он удаляет ссылку на 
объект из <code>jQuery.data</code> элемента, отключает все события из неймспейса&nbsp;виджета.</p>
<p>Метод <code>_destroy()</code> вызывается с помощью открытого метода <code>destroy()</code>. Мы сами можем добавить в него нужный&nbsp;функционал:</p>
<pre><code class="lang-js">$.widget( <span class="string">"custom.progressbar"</span>, {
    options: {
        value: <span class="number">0</span>
    },
    _create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">this</span>.options.value = <span class="keyword">this</span>._constrain(<span class="keyword">this</span>.options.value);
        <span class="keyword">this</span>.element.addClass( <span class="string">"progressbar"</span> );
        <span class="keyword">this</span>.refresh();
    },
    _setOption: <span class="function"><span class="keyword">function</span>(<span class="params"> key, value </span>) </span>{
        <span class="keyword">if</span> ( key === <span class="string">"value"</span> ) {
            value = <span class="keyword">this</span>._constrain( value );
        }
        <span class="keyword">this</span>._super( key, value );
    },
    _setOptions: <span class="function"><span class="keyword">function</span>(<span class="params"> options </span>) </span>{
        <span class="keyword">this</span>._super( options );
        <span class="keyword">this</span>.refresh();
    },
    refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">var</span> progress = <span class="keyword">this</span>.options.value + <span class="string">"%"</span>;
        <span class="keyword">this</span>.element.text( progress );
        <span class="keyword">if</span> ( <span class="keyword">this</span>.options.value == <span class="number">100</span> ) {
            <span class="keyword">this</span>._trigger( <span class="string">"complete"</span>, <span class="literal">null</span>, { value: <span class="number">100</span> } );
        }
    },
    _constrain: <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>) </span>{
        <span class="keyword">if</span> ( value &gt; <span class="number">100</span> ) {
            value = <span class="number">100</span>;
        }
        <span class="keyword">if</span> ( value &lt; <span class="number">0</span> ) {
            value = <span class="number">0</span>;
        }
        <span class="keyword">return</span> value;
    },
    _destroy: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">this</span>.element
            .removeClass( <span class="string">"progressbar"</span> )
            .text( <span class="string">""</span> );
    }
});
</code></pre>
<h1 id="-">Особенности вызова&nbsp;методов</h1>
<p>Widget factory создает и плагин и экземпляр объекта. Мы можем вызывать методы используя эти два&nbsp;подхода.</p>
<h2 id="-">Вызов метода из&nbsp;плагина</h2>
<pre><code class="lang-js">$( <span class="string">".selector"</span> ).dialog( <span class="string">"close"</span> );
$( <span class="string">".selector"</span> ).dialog( <span class="string">"option"</span>, <span class="string">"height"</span> ); <span class="comment">// вызов метода с параметром (получаем высоту)</span>
</code></pre>
<h2 id="-">Вызов метода из&nbsp;объекта</h2>
<p>По скольку каждый экземпляр каждого виджета храниться в <code>jQuery.data</code>, то мы можем просто доставать методы по&nbsp;ссылке:</p>
<pre><code class="lang-js"><span class="keyword">var</span> dialog = $( <span class="string">".selector"</span> ).data( <span class="string">"ui-dialog"</span> ); <span class="comment">// сохраняем ссылку на объект</span>
dialog.close(); <span class="comment">// вызываем методы напрямую</span>
</code></pre>
<p>Можно и так, с помощью метода <code>instance</code> (работает в jQuery <span class="caps">UI</span>&nbsp;1.11):</p>
<pre><code class="lang-js">$( <span class="string">".selector"</span> ).dialog( <span class="string">"instance"</span> ).close();
</code></pre>
<h2 id="-">Возвращаемые&nbsp;значения</h2>
<p>Когда мы используем вызов метода как из плагина, то возвращается jQuery-объект и мы можем продолжить цепочку. 
Исключение — методы, которые возвращают информацию о состоянии&nbsp;виджета:</p>
<pre><code class="lang-js"><span class="keyword">var</span> dialog = $( <span class="string">".selector"</span> ).dialog();

<span class="comment">// Plugin invocation - returns a jQuery object</span>
dialog.dialog( <span class="string">"close"</span> );

<span class="comment">// Therefore, plugin method invocation makes it possible to</span>
<span class="comment">// chain method calls with other jQuery functions</span>
dialog.dialog( <span class="string">"close"</span> )
    .css( <span class="string">"color"</span>, <span class="string">"red"</span> );

<span class="comment">// Запрашиваем информацию о состоянии виджета. jQuery-объект не вернется:</span>
$( <span class="string">".selector"</span> )
    .dialog( <span class="string">"isOpen"</span> )
    <span class="comment">// This will throw a TypeError</span>
    .css( <span class="string">"color"</span>, <span class="string">"red"</span> );
</code></pre>
<p>Когда мы вызываем метод из экземпляра, то вернется <code>undefined</code>:</p>
<pre><code class="lang-js"><span class="comment">// Instance invocation - returns undefined</span>
dialog.data( <span class="string">"ui-dialog"</span> ).close();
</code></pre>
<h1 id="-">Расширение функционала существующих&nbsp;виджетов</h1>
<p>Иногда нужно что-то подкрутить в существующем виджете или сделано новый на его основе. Обычно виджеты создаются 
фукнций <code>$.wiget</code>, которая получает два параметра: название виджета с нейспейсом и прототипный объект. Однако, если 
передать вторым параметром конструктор другого виджета, то он будет взят за&nbsp;основу:</p>
<pre><code class="lang-js">$.widget( <span class="string">"custom.superDialog"</span>, {} );              <span class="comment">// создание нового виджета без наследования</span>
$.widget( <span class="string">"custom.superDialog"</span>, $.ui.dialog, {} ); <span class="comment">// за основу будет взят $.ui.dialog</span>
</code></pre>
<p>В объекте, который передается третьим параметром мы можем переопределять или задавать собственные&nbsp;методы:</p>
<pre><code class="lang-js">$.widget( <span class="string">"custom.superDialog"</span>, $.ui.dialog, {
    red: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="keyword">this</span>.element.css( <span class="string">"color"</span>, <span class="string">"red"</span> );
    }
});

<span class="comment">// Create a new &lt;div&gt;, convert it into a superDialog, and call the red() method.</span>
$( <span class="string">"&lt;div&gt;I am red&lt;/div&gt;"</span> )
    .superDialog()
    .superDialog( <span class="string">"red"</span> );
</code></pre>
<h2 id="-">Расширение существующим&nbsp;методов</h2>
<p>Если в новом виджете создать метод с названием таким же, как у родительского, то мы его просто&nbsp;перетрем:</p>
<pre><code class="lang-js">$.widget( <span class="string">"custom.superDialog"</span>, $.ui.dialog, {
    open: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{ <span class="comment">// Был такой метод в $.ui.dialog, теперь его нету, только вывод в консоль</span>
        <span class="built_in">console</span>.log( <span class="string">"open"</span> );
    }
});

<span class="comment">// Create a new &lt;div&gt;, and convert it into a superDialog.</span>
$( <span class="string">"&lt;div&gt;"</span> ).superDialog();
</code></pre>
<p>Зачастую нам не нужно переписывать существующие мтоды, нам нужно их расширять. Это можно сделать с помощью методов 
<code>_super()</code> и <code>_superApply()</code>, которые вызовут одноименный метод из прототипного&nbsp;объекта:</p>
<pre><code class="lang-js">$.widget( <span class="string">"custom.superDialog"</span>, $.ui.dialog, {
    open: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log( <span class="string">"open"</span> );

        <span class="comment">// Invoke the parent widget's open(). Теперь все будет работать.</span>
        <span class="keyword">return</span> <span class="keyword">this</span>._super();
    }
});

$( <span class="string">"&lt;div&gt;"</span> ).superDialog();
</code></pre>
<p><code>_super</code> и <code>_superApply</code> отличаются так же, как <code>call()</code> и <code>apply()</code> для функций: первый получает список аргументов, 
второй — массив&nbsp;аргументов.</p>
<pre><code class="lang-js">$.widget( <span class="string">"custom.superDialog"</span>, $.ui.dialog, {
    _setOption: <span class="function"><span class="keyword">function</span>(<span class="params"> key, value </span>) </span>{

        <span class="comment">// Both invoke dialog's setOption() method. _super() requires the arguments</span>
        <span class="comment">// be passed as an argument list, _superApply() as a single array.</span>
        <span class="keyword">this</span>._super( key, value );
        <span class="keyword">this</span>._superApply( <span class="built_in">arguments</span> );
    }
});
</code></pre>
<h2 id="-">Переопределение&nbsp;виджетов</h2>
<p>Мы можем полностью переопределить виджет (не создавая новый) задав такое же имя, как и у&nbsp;прототипа:</p>
<pre><code class="lang-js">$.widget( <span class="string">"ui.dialog"</span>, $.ui.dialog, { <span class="comment">// Не будем создавать новый, будем расширять текущий</span>
    open: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log( <span class="string">"open"</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>._super();
    }
});

$( <span class="string">"&lt;div&gt;"</span> ).dialog();
</code></pre>
<h2 id="-">Переопределение методов в отдельных&nbsp;экземплярах</h2>
<p>Для этого пользуемся обычной <span class="caps">JS</span>-нотацией для&nbsp;объектов:</p>
<pre><code class="lang-js"><span class="keyword">var</span> dialogInstance = $( <span class="string">"&lt;div&gt;"</span> )
    .dialog()
    .data( <span class="string">"ui-dialog"</span> ); <span class="comment">// Retrieve the dialog's instance and store it.</span>

<span class="comment">// Override the close() method for this dialog</span>
dialogInstance.close = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log( <span class="string">"close"</span> );
};

<span class="comment">// Create a second dialog</span>
$( <span class="string">"&lt;div&gt;"</span> ).dialog();

<span class="comment">// Select both dialogs and call close() on each of them.</span>
<span class="comment">// "close" will only be logged once.</span>
$( <span class="string">":data(ui-dialog)"</span> ).dialog( <span class="string">"close"</span> );
</code></pre>
<h1 id="-">Материалы</h1>
<ul>
<li><a href="https://learn.jquery.com/jquery-ui/">https://learn.jquery.com/jquery-ui/</a></li>
<li><a href="http://learn.jquery.com/plugins/stateful-plugins-with-widget-factory/">http://learn.jquery.com/plugins/stateful-plugins-with-widget-factory/</a></li>
<li><a href="http://api.jqueryui.com/jQuery.widget">http://api.jqueryui.com/jQuery.widget</a></li>
<li><a href="http://devdocs.magento.com/guides/v2.0/coding-standards/code-standard-jquery-widgets.html">http://devdocs.magento.com/guides/v2.0/coding-standards/code-standard-jquery-widgets.html</a></li>
<li><a href="http://ajpiano.com/widgetfactory">http://ajpiano.com/widgetfactory</a></li>
<li><a href="http://www.slideshare.net/magentodev/take-more-from-jquery">http://www.slideshare.net/magentodev/take-more-from-jquery</a></li>
</ul>
<h1 id="-homework-">Домашняя работа <a href="/learn/articles/jquery-widget-factory/#homework"></a></h1>
<p>Задача — реализовать список с выделением, используя Widget&nbsp;Factory.</p>
<ul>
<li>Клик на элементе списка выделяет только&nbsp;его.</li>
<li>Ctrl (Cmd) + клик добавляет/убирает элемент из&nbsp;выделенных. </li>
<li>Shift + клик добавляет промежуток от последнего кликнутого к&nbsp;выделению. </li>
</ul>
<p><img src="/learn/articles/jquery-widget-factory/wf_homework.gif" alt=""></p>
<p>Нужно реализовать <span class="caps">API</span> виджета, чтобы можно было получить массив индексов выделенных элементов, выделить все элементы 
и снять выделение&nbsp;полностью.</p>
<p>Не забываем про деструктор. Нужно дать возможность разработчикам почистить за собой, когда виджет будет не&nbsp;нужен.</p>
<p>Обратите внимание на работу с событиями и метод <a href="http://api.jqueryui.com/jQuery.widget/#method-_on"><code>_on</code></a>. </p>
<p>Возможно, пригодиться вспомнить некоторые <a href="http://learn.javascript.ru/css-selectors"><span class="caps">CSS</span>-селекторы</a>, но можно и без&nbsp;них. </p>
<p>Примерный&nbsp;код:</p>
<pre><code class="lang-js"><span class="keyword">var</span> selectable = $(<span class="string">'#currencies'</span>).selectable({
    selected: <span class="function"><span class="keyword">function</span> (<span class="params">e, data</span>) </span>{
        $(<span class="string">'#selectedItems'</span>).text(data.selectedItems.join(<span class="string">', '</span>));
    }
}).data(<span class="string">'am-selectable'</span>);

<span class="comment">// selectable.someMethod('someParameter');</span>
<span class="comment">// selectable.destroy();</span>
</code></pre>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/learn/">« Назад на главную</a></div>
        <section class="about">
        </section>
        <section class="copy">
          <p>&copy; 2015 Andrey Miskov &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>